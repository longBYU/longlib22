C
C *** LAST REVISED ON 13-OCT-1994 07:48:42.12
C *** SOURCE FILE: [LONGLIB93.SOURCES.FORTRAN.LONGLIB]LL_NR.FOR
C revised 9/9/21 by dgl to minimize gfortran warnings
C       
C *************************************************************************
C
C	LONGLIB.FOR SOURCE CODE ROUTINES FOR THE PLOTTING LIBRARY
C
C	ONLY VECTOR PLOTTING IS SUPPORTED.
C
C	THIS FILE CONSITS OF THE FIRST SECTION OF THE MAIN PLOT ROUTINES.
C	THIS FILE CONSISTS OF THE DEVICE DEPENDENT ROUTINES.
C	THE RAMTEK COMMUNICATIONS ROUTINES ARE IN A SEPARATE FILE.
C	DEVICE DEPENDENT ROUTINES ARE ALSO CONTAINED IN THE CURSORLIB FILE.
C
C	THIS FILE REFLECTS VERSION 7 OF THE LONGLIB GRAPHICS LIBRARY
C
C	THE SOURCE CODE IN THIS FILE IS COMPATIBLE WITH THE ANSI
C	FORTRAN 77 STANDARDS WITH THE FOLLOWING EXCEPTIONS:
C		1. TABS (^I) ARE USED TO INDENT LINES.
C		2. TRAILING COMMENTS WITH A "!" CHARACTER ARE USED
C		   EXTENSIVELY.
C		3. AN "INTEGER*2" DECLARTION IS USED IN PPLOTP.
C		   THIS MAY REPLACED BY AN "INTEGER" STATMENT AT THE EXPENSE
C		   OF LARGER PRINTER HISTORY FILE SIZES
C		4. SUBROUTINE AND VARIABLE NAMES OCCASIONALLY EXCEED
C		   SIX CHARACTERS IN LENGTH.
C
C	THE FOLLOWING ARE MACHINE DEPENDENT:
C		1. THE '$' IN A FORMAT STATEMENT CAUSES THE CURSOR
C		   TO BE LEFT AT THE END OF THE STATEMENT ON A PROMPT
C		2. COMMON BLOCKS ARE ASSUMED TO ALWAYS BE SAVED AND
C		   AVAILABLE FOR USE BY ANY ROUTINE AT ANY TIME.
C		3. THE FUNCTION "IAND" RETURNS THE BIT-WISE AND OF TWO
C		   INTEGER ARGUMENTS WHILE "IOR" RETURNS BIT-WISE OR.
C		4. THE READ AND WRITE LOGICAL FILE UNITS FOR TERMINAL
C		   ARE "*".
C		5. ROUTINES TO SUPPORT THE VAX CONTROL-C INTERRUPT
C		   ARE INCLUDED BUT MAY BE COMMENTED OUT.
C		6. THE ROUTINE "EXIT" IN FRAME STOPS THE EXECUTION
C		   OF THE PROGRAM
C
C *************************************************************************
C
	SUBROUTINE FRAME(IPL,ID,VPX,VPY,ZOM)
C
C	ROUTINE TO INTIALIZE THE LONGLIB GRAPHICS PLOT PACKAGE
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	+ ADD CONTROL-C INTERRUPT ENABLE CALL
C	  CAN BE COMMENTED OUT IF DESIRED
C
C	IPL	LOGICAL DEVICE NUMBER FOR PRINTER DATA FILE (NORMALLY 3)
C		> 0 FORTRAN FILE TYPE NUMBER
C		= 0 ASK IF PRINT FILE DESIRED (DEFAULT FILE 3)
C		< 0 DO NOT CREATE PRINTER FILE
C	ID	DEVICE TYPE
C		< 0 DO NOT CLEAR SCREEN OF SCREEN DEVICE
C		= 0 ASK WHICH SCREEN DEVICE TO USE (? FOR HELP)
C		= 1 USE VT100 TERMINAL EQUIPPED WITH SELNAR GR100+
C		= 2 USE RAMTEK (LARGE 1280x1024) ONLY
C		= 3 USE BOTH LARGE RAMTEK AND VT100 WITH SELNAR GR100 OR GR100+
C		= 4 USE NO SCREEN DEVICE
C		= 5 USE VT125 TERMINAL IN TEKTRONICS 4010 MODE
C		= 6 USE VT100 TERMINAL WITH SELNAR GR100 IN TEKTRONICS 4010 MODE
C		= 7 USE VT100 TERMINAL WITH SELNAR GR480
C		= 8 USE VT240 TERMINAL (TEK 4010 MODE, VT100 MODE)
C		= 9 USE VT220 TERMINAL WITH SELNAR SG220 (TEK 4014)
C		= 10 USE TEKTRONICS 4010 TERMINAL
C		= 11 USE TEKTRONICS 4107 COLOR TERMINAL
C		= 12 USE GRAPHON GO-235 TERMINAL
C		> 50 RAMTEK AND TERMINAL.  TERMINAL CODE=MOD(ID,50)
C	VPX,VPY COORDINATES OF BOTTOM LEFT ORIGIN
C	ZOM	ZOOM FACTOR
C		< 0 USE SMALL RAMTEK SCREEN
C
	CHARACTER*1 ANS
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/,/RMTEK/,/VT100/
	COMMON/RMTEK/ICHAN,IMR(128),RRE(2),ROX,ROY,RSF,NIMR,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	integer idarr(4)
C       
	CALL ENABLEAST			! ENABLE CONTROL-C INTERRUPT CODE
C
	KPL=IPL
	Z=ZOM
	IF (KPL.EQ.0) THEN
16		WRITE(*,1)
1		FORMAT(' Create Longlib Meta File? (Y/N) [N] ',$)
		READ(*,2,END=99) ANS
2		FORMAT(A1)
		IANS=ICHAR(ANS)
		KPL=-3
		IF (IANS.EQ.89.OR.IANS.EQ.121) KPL=3
		IF (IANS.EQ.63) GOTO 16
	ENDIF
	LU=-1
	IF (KPL.GT.0) CALL PPLOTS(KPL,VPX,VPY,ABS(Z))	! INTIALIZE PRINTER
	IDD=IABS(ID)
	IDDN=-ISIGN(1,ID)			! SET CLEAR SCREEN FLAG
	IF (IDD.EQ.0) THEN
		IDDN=-1		! CLEAR SCREEN WHEN PROMPTED
5		WRITE(*,3)
3		FORMAT(' Longlib Screen Graphics Device? [?=Help] ',$)
		READ(*,2,END=99) ANS
C
C	CONVERT INPUT CHARACTER INTO UPPER CASE ASCII VALUE
C
		IANS=ICHAR(ANS)
		IF (IANS.GT.96) IANS=IANS-32
C
C	INPUT WAS A QUESTION MARK?
C
		IF (IANS.EQ.63) THEN
			WRITE(*,4)
4		FORMAT(/' Available Screen Devices:'/,4X,'R : 1024 Ramtek'/
     $		4X,'r : 512 Ramtek'/,4X,'V : Vt100 w/Selnar Gr100'/,4X,
     $		'T : VT125'/,4X,'F : VT240'/,4X,
     $		'D : VT220 w/Selnar Sg220'/,4X,'E : Tektronics 4010/14'/,
     $		4X,'A : Tektronics 4107/109'/,4X,'G : GraphOn GO-235'/,
     $		4X,'X : Xterm '/,4X,'H : Huge Ramtek'/,4X,'B : Big Ramtek'/
     $		4X,'L : Little Ramtek'/4X,'M : Minature Ramtek'/
     $		4X,'P : Pico Ramtek'/
     $		4X,'Z : Exit'/,4X,'N : None [default]'/)
			GOTO 5
		ENDIF
		IDD=4		! DEFAULT = NO SCREEN DEVICE
C
C	DECODE TERMINAL SCREEN OPTION
C
		IF (IANS.EQ.90) GOTO 99	! END PROGRAM (Z)
		IF (IANS.EQ.82.OR.IANS.EQ.50.OR.IANS.EQ.51) THEN
			IDD=2		! LARGE RAMTEK
			IF (ICHAR(ANS).EQ.114) Z=-ABS(Z)! SMALL RAMTEK
		ENDIF
		IF (IANS.EQ.84) IDD=5	! VT125 4010 (T)
		IF (IANS.EQ.83) IDD=6 	! SELNAR GR100 (S)
		IF (IANS.EQ.86) IDD=6	! SELNAR GR100 (V)
		IF (IANS.EQ.75) IDD=6	! SELNAR GR100 (K)
		IF (IANS.EQ.70) IDD=8	! VT240 (4010) (F)
		IF (IANS.EQ.68) IDD=9	! VT220 (4010) (D)
		IF (IANS.EQ.69) IDD=10	! Tektronics 4010/4014 (E)
		IF (IANS.EQ.65) IDD=11	! Tektronics 4107/4109 (A)
		IF (IANS.EQ.71) IDD=12	! GRAPHON GO-235 (ENHANCED) (G)
		IF (IANS.EQ.88) IDD=13	! XTERM PROGRAM WITH TEKTRONICS (X)
		IF (IANS.EQ.72) IDD=51	! HUGE RAMTEK (H)
		IF (IANS.EQ.76) IDD=52	! LITTLE RAMTEK (L)
		IF (IANS.EQ.66) IDD=54	! BIG RAMTEK (B)
		IF (IANS.EQ.77) IDD=53	! MINATURE RAMTEK (M)
		IF (IANS.EQ.80) IDD=55	! PICO RAMTEK (P)
	ENDIF
	ICHAN=-1		! DISABLE RAMTEK BY DEFAULT 
	IVT100=-1		! DISABLE TERMINAL BY DEFAULT
	IF (IDD.NE.2.AND.IDD.NE.4.AND.IDD.LT.50) 
     $		CALL VPLOTS(IDD*IDDN,VPX,VPY,Z) ! INITALIZE VT100
	IF (IDD.EQ.2.OR.IDD.EQ.3.OR.IDD.GT.50) THEN
		IF (IDD.EQ.2) IDD=1
		IF (IDD.EQ.3) IDD=1
		IF (IDD.GT.50) IDD=IDD-50
		idarr(1)=IDD*IDDN
		CALL RPLOTS(idarr,VPX,VPY,Z) ! INTIALIZE RAMTEK
	ENDIF
	RETURN
99	CONTINUE
C
C	DO IMMEDIATE EXIT FROM PROGRAM
C
	CALL EXIT(0)
	RETURN
	END
C
C
	SUBROUTINE PLOTS(I,J)
C
C	THIS SUBROUTINE PROVIDES PLOTS-10 COMPATIBILITY
C	ARGUMENTS ARE IGNORED.  CALL FRAME WITH PROMPT FOR
C	HARDCOPY AND GRAPHICS SCREEN OUTPUTS.
C
	CALL FRAME(0,0,0.,0.,1.)
	RETURN
	END
C
C
	SUBROUTINE VPLOTS(ID,VPX,VPY,ZOM)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C	THIS ROUTINE INITIALIZES THE TERMINAL GRAPHICS DEVICE
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	SAVE /VT100/
C
	NIMV=1			! RESET VECTOR BUFFTER
	IMV(1)=0		! ORIGIN VECTOR BUFFER
	IMV(2)=0		! ORIGIN VECTOR BUFFER
	VOX=VPX 		! ORIGIN
	VOY=VPY 		! ORIGIN
	VSF=ABS(ZOM)		! SCALE FACTOR
	VANG=0.
	ITERM=1			! SELNAR GR100	(DEFAULT)
	IF (IABS(ID).EQ.5) ITERM=2	! VT125 TEK 4010 MODE
	IF (IABS(ID).EQ.8) ITERM=3	! VT240 TEK 4010 MODE
	IF (IABS(ID).EQ.9) ITERM=4	! VT220 W/SELNAR SG220 (TEK 4014)
	IF (IABS(ID).EQ.10) ITERM=5	! Tektronics 4010/4014
	IF (IABS(ID).EQ.11) ITERM=6	! Tektronics 4107/4109
	IF (IABS(ID).EQ.12) ITERM=7	! GRAPHON GO-235
	IF (IABS(ID).EQ.13) ITERM=8	! XTERM
	IF (VSF.LE.0.0) VSF=1.0
	VRE(1)=9.5/4096.! TEK 4010 RESOLUTION X (1024 PIXELS = 9.5 INCHES)
	VRE(2)=VRE(1)
	VLIM(1)=4095.	! TEK 4010 SCREEN PIXEL SIZE (X)
	VLIM(2)=3119.	! TEK 4010 SCREEN PIXEL SIZE (Y)
	IXLIM=int(VLIM(1))
	IYLIM=int(VLIM(2))
	IYREV=0		! DO NOT INVERT Y DIMENSION COORDINATE
	IF (ITERM.EQ.5.OR.ITERM.EQ.8) THEN	! TEK 4014 MODE SCALING WITH FULL SIZE SCREEN
		VRE(1)=9.5/4096.! TEK 4014 RESOLUTION X (1024 PIXELS = 9.5 INCHES)
		VRE(2)=VRE(1)
		VLIM(1)=4095.	! TEK 4014 SCREEN PIXEL SIZE (X)
		VLIM(2)=4095.	! TEK 4010 SCREEN PIXEL SIZE (Y)
		IXLIM=int(VLIM(1))
		IYLIM=int(VLIM(2))
		IYREV=0		! DO NOT INVERT Y DIMENSION COORDINATE
	ENDIF
	IF (ITERM.EQ.6) THEN	! TEK 4107 MODE SCALING
		VRE(1)=10./4096.! TEK 4107 RESOLUTION X (4107 PIXELS = 10 INCHES)
		VRE(2)=VRE(1)
		VLIM(1)=4095.	! TEK 4107 SCREEN PIXEL SIZE (X)
		VLIM(2)=4095.	! TEK 4107 SCREEN PIXEL SIZE (Y)
		IXLIM=int(VLIM(1))
		IYLIM=int(VLIM(2))
		IYREV=0		! DO NOT INVERT Y DIMENSION COORDINATE
	ENDIF
	IVT100=1		! ENABLE TERMINAL GR OUTPUT
	CALL CTERM(0)		! SET TERMINAL TO GR SCREEN
	VVP(1)=0.0		! VIEW PORT PARAMETERS LOWER-LEFT
	VVP(2)=0.0
	CALL PLOTVT(999.,999.,4)! SET RIGHT VIEWPORT PARAMETERS UPPER-RIGHT
	IF (ID.LE.0) CALL PLOTVT(-1.,0.,0)	! CLEAR TERMINAL SCREEN
	CALL NEWVPEN(0,1)			! SET DEFAULT PEN TYPE,WIDTH
	CALL NEWVCOL(-1)			! INIT. COLOR GRAPHICS
	CALL NEWVCOL(1)				! SET DEFAULT PEN COLOR
	RETURN
	END
C
C
	SUBROUTINE VTPLOT(N,M,IE,LWIDE)
C
C	PLOTS PIXEL MAPPED VECTOR TO TERMINAL GRAPHICS SCREEN
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C	TERMINAL MUST BE IN GRAPHICS MODE PRIOR TO CALL
C
C N	NUMBER OF POINTS
C M	ARRAY OF POINTS TO BE OUTPUT
C		M(1) = X1
C		M(2) = Y1
C		M(3) = X2
C		M(4) = Y2,... ETC
C IE    ERASE FLAG 
C		0=NORMAL (DRAW VISIBLE)
C		1=XOR    (IF NOT SUPPORTED, DRAW VISIBLE)
C		2=ERASE  (IF NOT SUPPORTED, DRAW VISIBLE)
C		3=XOR    (IF NOT SUPPORTED, DRAW ERASE)
C LWIDE	LINE WIDTH (SIMULATED)
C
	INTEGER M(*)
	INTEGER ESC,US,GS,HIX,LOX,HIY,LOY,EX,LHIX,LHIY,LLOY,LEX
	CHARACTER*1 B(79)
	LOGICAL EXTRA
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	SAVE /VT100/
C
C	LINE WIDTH ARRAYS
C
	INTEGER MWP(4),MWX(26),MWY(26)
	DATA MWP/1,5,12,26/
	DATA MWX/0,-1,1,1,-1,-1,0,2,1,0,0,-1,0,-1,-1,-1,0,0,1,1,1,1,
     $   1,0,0,-1/
	DATA MWY/0,0,1,-1,-1,0,2,0,0,-1,-1,0,-1,0,0,1,1,1,1,0,0,0,-1,
     $   -1,-1,-1/
	DATA ESC/27/,GS/29/,US/31/
C
	IF (N.LT.1.OR.IVT100.LT.0) RETURN
C
C	USE EXTRA TEKTRONICS CHARACTER?
C
	EXTRA=.FALSE.
	IF (ITERM.EQ.6) EXTRA=.TRUE.	
C
	IF (IE.NE.0) THEN			 ! ERASE OR XOR DESIRED
		IF (ITERM.EQ.4) WRITE(*,77) ESC,CHAR(96+IE)! SELNAR SG220 ERASE/XOR
77		FORMAT(' ',A1,'OW ',A1,'` @@',$) ! SELNAR SG220 ERASE/XOR
		IF (ITERM.EQ.7) THEN		! GRAPHON G0-235
			IF (IE.EQ.2) THEN	! ERASE
				WRITE(*,125) CHAR(ESC),CHAR(16)
			ELSE			! XOR
				WRITE(*,125) CHAR(ESC),CHAR(21)
			ENDIF
		ENDIF
	ENDIF
C
C	MAKE MULTIPLE PASSES TO SIMULATE LINE WIDTH	
C
	IADD=4
	IF (EXTRA) IADD=1
C
	LW1=MIN(LWIDE,7)
	LW1=MAX(LW1,1)
	LW=MWP(LW1)
	DO 500 IW=1,LW
C
C	SET TEKTRONICS VECTOR MODE GRAPHICS COMMAND
C
	B(1)=CHAR(GS)
	IB=2
C
C	COMPUTE HI-RES TEKTRONICS COORDINATES BUT SEND ONLY APPROPRIATE DATA
C
	N2=2*N
	DO 100 I=1,N2,2
C
		M(I)  =M(I)  +MWX(IW)*IADD
		M(I+1)=M(I+1)+MWY(IW)*IADD
		MX=M(I)
		MY=M(I+1)
C
C	CLIP TO SCREEN COORDINATES
C
		MX=MIN(MX,4095)
		MY=MIN(MY,4095)
		MX=MAX(MX,0)
		MY=MAX(MY,0)
C
C	COMPUTE HI-RES TEKTRONICS COORDINATES
C
		HIX=32+MX/128			! HI-X
		LOX=64+MOD(MX/4,32)		! LO-X
		HIY=32+MY/128			! HI-Y
		LOY=96+MOD(MY/4,32)		! LO-Y
		EX=96+MOD(MY,4)*4+MOD(MX,4)	! EXTRA
C
C	USE TEXTRONICS CODING STANDARD TO MINIMIZE CHARACTERS SET TO TERMINAL
C
		IF (I.GT.1) THEN
			IF (LHIY.NE.HIY) THEN
				B(IB)=CHAR(HIY)
				IB=IB+1
			ENDIF
			IF (EXTRA.AND.LEX.NE.EX) THEN
				B(IB)=CHAR(EX)
				B(IB+1)=CHAR(LOY)
				IB=IB+2
				IF (LHIX.NE.HIX) THEN
					B(IB)=CHAR(HIX)
					IB=IB+1
				ENDIF
			ELSE
				IF (LOY.NE.LLOY) THEN
					B(IB)=CHAR(LOY)
					IB=IB+1
					IF (LHIX.NE.HIX) THEN
						B(IB)=CHAR(HIX)
						IB=IB+1
					ENDIF
				ELSE
					IF (LHIX.NE.HIX) THEN
						B(IB)=CHAR(LOY)
						B(IB+1)=CHAR(HIX)
						IB=IB+2
					ENDIF
				ENDIF
			ENDIF
			B(IB)=CHAR(LOX)
			IB=IB+1
		ELSE
			B(IB)=CHAR(HIY)
			IB=IB+1
			IF (EXTRA) THEN
				B(IB)=CHAR(EX)
				IB=IB+1
			ENDIF
			B(IB)=CHAR(LOY)
			B(IB+1)=CHAR(HIX)
			B(IB+2)=CHAR(LOX)
			IB=IB+3
		ENDIF
		LHIX=HIX
		LHIY=HIY
		LLOY=LOY
		LEX=EX
		IF (IB.GT.73) THEN	! DUMP LINE BUFFER
			B(IB)=CHAR(US)
			WRITE(*,125) (B(J),J=1,IB)
			B(1)=CHAR(GS)
			B(2)=CHAR(LOX)
			IB=3
		ENDIF
100	CONTINUE
C
	B(IB)=CHAR(US)		! END VECTOR MODE
	IF (IB.GT.3) WRITE(*,125) (B(J),J=1,IB)
125	FORMAT(' ',79A1)
C
500	CONTINUE
C
	IF (IE.NE.0) THEN		! ERASE OR XOR DESIRED
	  IF (ITERM.EQ.4) WRITE(*,77) CHAR(ESC),CHAR(96) ! RESTORE SELNAR SG220 NORM WRIIT
	  IF (ITERM.EQ.7) WRITE(*,125) CHAR(ESC),CHAR(1) ! GRAPHON
	ENDIF
	RETURN
	END
C
C
	SUBROUTINE NEWVPEN(IT,IW)
C
C	THIS ROUTINE CHANGES THE TERMINAL LINE TYPE ON TERMINAL
C	TERMINAL MUST BE IN GRAPHICS MODE
C
C	IT = LINE TYPE (IF TERMINAL HARDWARE SUPPORTS)
C	IW = LINE WIDTH (IF SUPPORTED)
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	SAVE /VT100/
C
	INTEGER ESC
	DATA ESC/27/
C
	IF (IVT100.LT.0) RETURN
	MV=IT
	MVW=IW
C
CC	IF (ITERM.EQ.6) WRITE(*,20) ESC,'M','V',IT+47	! TEK4107
	WRITE(*,20) CHAR(ESC),CHAR(IT+96)		! TEK COMMAND FORMAT
20	FORMAT(' ',2A1,$)
	RETURN
	END
C
C
	SUBROUTINE NEWVCOL(IC)
C
C	THIS ROUTINE CHANGES THE TERMINAL LINE COLOR
C	TERMINAL MUST BE IN GRAPHICS MODE
C
C	IC = LINE COLOR (IF SUPPORTED BY TERMINAL HARDWARE)
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
C	SAVE /VT100/
C
	INTEGER ESC
	DATA ESC/27/
C
	IF (IVT100.LT.0) RETURN
	IF (IC.LT.0) THEN		! INITIALIZE COLOR GRAPHICS
	ELSE				! CHANGE LINE COLOR
		IVCOL=IC
		IF (ITERM.EQ.6) THEN	! TEK4107 COLOR COMMAND
			WRITE(*,20) CHAR(ESC),CHAR(MOD(IC,15)+48)
20			FORMAT(' ',A1,'ML',A1)
		ENDIF
	ENDIF
	RETURN
	END
C
C
	SUBROUTINE CTERM(IX)
C
C	FORTRAN-77 VERSION:   DGL JUNE 1990
C
C	CONTROLS A GRAPHICS TERMINAL
C
C	NOTE: NOT ALL OPTIONS ARE AVAILABLE IN ALL GRAPHICS DEVICES.
C
C IX	CONTROL FLAG
C	= 0 PUT TERMINAL IN GRAPHICS MODE, CLEAR TERMINAL SCREEN
C	= 1 RETURN TERMINAL TO TERMINAL MODE
C	=-1 RETURN TERMINAL TO GRAPHICS MODE
C	= 2 RETURN TERMINAL TO TERMINAL MODE, ASK IF GRAPHICS SCREEN CLEAR
C	=-2 RETURN TERMINAL TO TERMINAL MODE, CLEAR SCREEN
C	= 3 CLEAR TERMINAL SCREEN, LEAVE IN GRAPHICS MODE
C	=-3 CLEAR GRAPHICS SCREEN, LEAVE IN GRAPHICS MODE
C	= 4 DUMP GRAPHICS SCREEN TO PRINTER, LEAVE IN GRAPHICS
C	=-4 CLEAR TERMINAL AND GRAPHICS SCREEN, LEAVE IN GRAPHICS MODE
C	= 5 TURN OFF GRAPHICS SCREEN, RETURN TO TERMINAL MODE
C	=-5 TURN ON GRAPHICS SCREEN, RETURN TO GRAPHICS MODE
C	= 6 TOGGLE REVERSE VIDEO, LEAVE IN GRAPHICS
C	= 8 RESTORE TERMINAL TO ANSI MODE
C
C	FOR SELNAR EQUIPPED VT100, VT220 AND VT125, CTERM SWITCHES BACK AND
C	FORTH BETWEEN THE TERMINAL MODE AND GRAPHICS MODE.  THE VT240 CLEARS
C	THE SCREEN EACH TIME THIS IS DONE SO THIS EFFECT IS INHIBITED.  FOR THE
C	VT240, CTERM ONLY SWITCHES IT INTO THE TEK 4010 MODE AND LEAVES IT
C	THERE UNTIL THE (8) CALL WHEN PLOTND IS CALLED.
C
C	TERMINALS WHICH DO NOT HAVE THE TEXT AND GRAPHICS ON SEPARATE
C	PLANES SET THE ALPHA CURSOR TO THE HOME POSITION BEFORE RETURNING
C	TO "TEXT" POSITION.
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	integer ITOG
	SAVE /VT100/
C
C	ESCAPE SEQUENCES REQUIRED TO CONTROL TERMINAL/GRAPHICS MODE
C	DIMENSIONED: ACTION(#CHARACTERS+1,#OF DEVICES)
C		#DEVICES = 6, #CHARACTERS=7
C	NOTE: LAST CHARACTER CONTAINS NUMBER OF CHARS IN COMMAND ACTIONS:
C	"VTERM" PUTS TERMINAL IN TERMINAL MODE
C	"GTERM" PUTS TERMINAL IN GRAPHICS MODE
C	"VCLEAR" CLEARS TERMINAL MODE SCREEN
C	"GCLEAR" CLEARS GRAPHICS MODE SCREEN
C
	CHARACTER*1 ANS
C
	INTEGER VTERM(7,8),GTERM(7,8),VCLER(7,8),GCLER(7,8)
	INTEGER SG10VT(7), SG10GT(7), SG10VC(7), SG10GC(7) ! SELNAR GR100 TEK MODE
	INTEGER VT12VT(7), VT12GT(7), VT12VC(7), VT12GC(7)  ! VT125+RETRO
	INTEGER VT24VT(7), VT24GT(7), VT24VC(7), VT24GC(7)  ! VT240 4010 MODE
	INTEGER VT22VT(7), VT22GT(7), VT22VC(7), VT22GC(7)  ! VT220 SG100
	INTEGER T401VT(7), T401GT(7), T401VC(7), T401GC(7)  ! TEK 4010
	INTEGER T410VT(7), T410GT(7), T410VC(7), T410GC(7)  ! TEK 4107
	INTEGER GO23VT(7), GO23GT(7), GO23VC(7), GO23GC(7)  ! GRAPHON GO-235
	INTEGER XTVT(7), XTGT(7), XTVC(7), XTGC(7)  ! XTERM
C
	EQUIVALENCE (VTERM(1,1), SG10VT),(GTERM(1,1), SG10GT),
     $		    (VCLER(1,1), SG10VC),(GCLER(1,1), SG10GC)
	EQUIVALENCE (VTERM(1,2), VT12VT),(GTERM(1,2), VT12GT),
     $		    (VCLER(1,2), VT12VC),(GCLER(1,2), VT12GC)
	EQUIVALENCE (VTERM(1,3), VT24VT),(GTERM(1,3), VT24GT),
     $		    (VCLER(1,3), VT24VC),(GCLER(1,3), VT24GC)
	EQUIVALENCE (VTERM(1,4), VT22VT),(GTERM(1,4), VT22GT),
     $		    (VCLER(1,4), VT22VC),(GCLER(1,4), VT22GC)
	EQUIVALENCE (VTERM(1,5), T401VT),(GTERM(1,5), T401GT),
     $		    (VCLER(1,5), T401VC),(GCLER(1,5), T401GC)
	EQUIVALENCE (VTERM(1,6), T410VT),(GTERM(1,6), T410GT),
     $		    (VCLER(1,6), T410VC),(GCLER(1,6), T410GC)
	EQUIVALENCE (VTERM(1,7), GO23VT),(GTERM(1,7), GO23GT),
     $		    (VCLER(1,7), GO23VC),(GCLER(1,7), GO23GC)
	EQUIVALENCE (VTERM(1,8), XTVT),(GTERM(1,8), XTGT),
     $		    (VCLER(1,8), XTVC),(GCLER(1,8), XTGC)
C
	INTEGER ESC, HOME(6)
	DATA ESC/27/			! ASCII ESCAPE
	DATA HOME/29,63,111,32,64,31/	! CURSOR IN VT100 UL POSITION
C
	DATA SG10VT/27,50,0,0,0,0,2/		! <ESC>2      SELNAR GR100 IN
	DATA SG10GT/27,49,27,42,0,0,4/		! <ESC>1<ESC>* TEK 4010 MODE
	DATA SG10VC/27,91,50,74,0,0,4/		! <ESC>[2J
	DATA SG10GC/27,42,27,12,0,0,4/		! <ESC>*<ESC><FF>
C
	DATA VT12VT/24,0,0,0,0,0,1/		! <CAN>(^X) VT125 (VT100+RETRO)
	DATA VT12GT/29,0,0,0,0,0,1/		! <GS> (^])
	DATA VT12VC/27,91,50,74,0,0,4/		! <ESC>[2J
	DATA VT12GC/27,12,0,0,0,0,2/		! <ESC><FF>
C
	DATA VT24VT/27,91,63,51,56,108,0/	! <ESC>[?38l  VT240 7 BIT 
	DATA VT24GT/27,91,63,51,56,104,0/	! <ESC>[?38h	CONTROLS
	DATA VT24VC/27,91,50,74,0,0,0/		! <ESC>[2J
	DATA VT24GC/27,12,0,0,0,0,2/		! <ESC><FF>
C
	DATA VT22VT/27,50,27,91,52,105,6/	! <ESC>2<ESC>[4i  VT220 (SG220)
	DATA VT22GT/27,91,53,105,27,49,6/	! <ESC>[5i<ESC>1  
	DATA VT22VC/27,91,50,74,0,0,4/		! <ESC>[2J
	DATA VT22GC/27,12,0,0,0,0,2/		! <ESC><FF>
C
	DATA T401VT/0,0,0,0,0,0,0/		! Tek 4010/4014
	DATA T401GT/0,0,0,0,0,0,0/		! 
	DATA T401VC/27,12,0,0,0,0,2/		! <ESC><FF>
	DATA T401GC/27,12,0,0,0,0,2/		! <ESC><FF>
C
	DATA T410VT/0,0,0,0,0,0,0/		! Tek 4107/4109
	DATA T410GT/0,0,0,0,0,0,0/		!
	DATA T410VC/27,76,90,0,0,0,3/		! <ESC>LZ (DIALOG CLEAR)
	DATA T410GC/27,12,0,0,0,0,2/		! <ESC><FF>
C
	DATA GO23VT/24,0,0,0,0,0,1/		! <CAN>  GRAPHON GO-235
	DATA GO23GT/29,0,0,0,0,0,1/		! <GS>
	DATA GO23VC/27,91,50,74,0,0,4/		! <ESC>[2J
	DATA GO23GC/27,97,27,12,0,0,4/		! <ESC>a<ESC><FF>
C
	DATA XTVT/27,3,0,0,0,0,2/		! <ESC><ETX> XTERM
	DATA XTGT/27,91,63,51,56,104,7/		! <ESC>[?38h
	DATA XTVC/27,91,50,74,0,0,4/		! <ESC>[2J
	DATA XTGC/27,12,0,0,0,0,2/		! <ESC><FF>
C
	DATA ITOG/0/			! SCREEN TOGGLE FLAG
	data iskip/0/
C       
	IF (IVT100.EQ.-99.AND.IX.EQ.2) GOTO 80	! SPECIAL SKIP PLOTTING IN EFFECT
	IF (IVT100.LE.0) RETURN			! TERMINAL NOT IN USE
	IF (IABS(IX).GT.8) RETURN		! INVALID OPTION
C
C	OPTION SWITCH
C
1	FORMAT(' ',6A1,$)
	GOTO (60,30,100,120,20,85,70,10,40,80,15,130,110,30,50,180),IX+8
99	RETURN
C
10	CONTINUE				! INIT GR SCREEN, CLEAR TERMINAL SCREEN ONLY
	IF (ITERM.EQ.6) THEN
C						! TEK4107 ANSI MODE CLEAR SCREEN
		WRITE(*,1) CHAR(ESC),CHAR(91),CHAR(50),CHAR(74)
C						! TEK4107 TO TEK MODE
		WRITE(*,1) CHAR(ESC),CHAR(37),CHAR(33),CHAR(48)
	ENDIF
	WRITE(*,1) (CHAR(VTERM(I,ITERM)),I=1,VTERM(7,ITERM))
	WRITE(*,1) (CHAR(VCLER(I,ITERM)),I=1,VCLER(7,ITERM))
	WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,GTERM(7,ITERM))
	WRITE(*,1) (CHAR(GCLER(I,ITERM)),I=1,GCLER(7,ITERM))
	IMODE=1				! GRAPHICS MODE
	GOTO 99
15	CONTINUE			! CLEAR TERMINAL SCREEN, GR MODE
	WRITE(*,1) (CHAR(VTERM(I,ITERM)),I=1,VTERM(7,ITERM))
	WRITE(*,1) (CHAR(VCLER(I,ITERM)),I=1,VCLER(7,ITERM))
	WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,GTERM(7,ITERM))
	IF (ITERM.EQ.4) WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,6)	! VT240
	IMODE=1				! GRAPHICS MODE
	GOTO 99
20	CONTINUE			! CLEAR GRAPHICS SCREEN, GR MODE
	IF (ITERM.EQ.4) WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,6)	! VT240
	WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,GTERM(7,ITERM))
	WRITE(*,1) (CHAR(GCLER(I,ITERM)),I=1,GCLER(7,ITERM))
	IMODE=1				! GRAPHICS MODE
	GOTO 99
30	CONTINUE				! TOGGLE VIDEO SCREEN
C							! SELNARS
	IF (ITERM.EQ.1) WRITE(*,1) CHAR(ESC),CHAR(48),CHAR(ESC),CHAR(40)
C							! GRAPHON
	IF (ITERM.EQ.7) WRITE(*,1) CHAR(ESC),CHAR(91),CHAR(49+ITOG),
     $				   CHAR(35),CHAR(122)
	ITOG=ITOG+1
	IF (ITOG.GE.2) ITOG=1
	GOTO 99
40	CONTINUE				! TERMINAL MODE
	WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,GTERM(7,ITERM))
	WRITE(*,1) (CHAR(HOME(I)),I=1,6)
	WRITE(*,1) (CHAR(VTERM(I,ITERM)),I=1,VTERM(7,ITERM))
	IMODE=0				! TERMINAL MODE
	GOTO 99
50	CONTINUE
60	CONTINUE
	GOTO 99
70	CONTINUE				! GRAPHICS MODE
	WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,GTERM(7,ITERM))
	IMODE=1				! GRAPHICS MODE
	GOTO 99
80	CONTINUE				! CLEAR SCREEN PROMPT
	IF (IVT100.EQ.-99) THEN		! MULTIPLE PASS SKIPPING
		ISKIP=ISKIP-1
		IF (ISKIP.GT.0) GOTO 99
	ELSE
		ISKIP=0
	ENDIF
	WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,GTERM(7,ITERM))
CC	WRITE(*,1) (CHAR(HOME(I)),I=1,6)
	WRITE(*,1) (CHAR(VTERM(I,ITERM)),I=1,VTERM(7,ITERM))
	IMODE=0				! TERMINAL MODE
505	WRITE(*,5)
5	FORMAT(' Clear Screen? (y,n,q,s,d) [y] ',$)
	READ(*,6) ANS
6	FORMAT(A1)
C
C	CONVERT INPUT CHARACTER TO UPPER CASE ANSII
C
	IANS=ICHAR(ANS)
	IF (IANS.GE.96) IANS=IANS-32
C
C	QUESTION MARK REPLY
C
	IF (IANS.EQ.63) THEN
		WRITE(*,84)
84		FORMAT(/' Y : Clear screen [default]'/' n : No clear '/
     $		' q : Quit (disable screen plotting)'/
     $		' s : Skip screen plotting until next "cterm(2)"'/
     $		' p : Skip screen plotting until specified "cterm(2)"'/
     $		' d : Dump screen to terminal printer'/)
		GOTO 505
	ENDIF
C
C	Y OR NO REPLY
C
	IF (IANS.EQ.89.OR.IANS.EQ.32) THEN
		IVT100=1			! ONLY WHEN IVT100=-99
		GOTO 85
	ELSE
		IF (IANS.EQ.81) IVT100=-1	! TURN OFF VT100 PLOTTING
		IF (IANS.EQ.83) THEN		! SKIP PLOTTING
			IVT100=-99  
			ISKIP=0
		ENDIF
		IF (IANS.EQ.68) GOTO 130	! DUMP TO PRINTER
		IF (IANS.EQ.80) THEN		! PASS SKIP
			IVT100=-99  
			WRITE(*,86)
86			FORMAT(' Number of CTERM(2)s to skip? ',$)
			READ(*,*) ISKIP
		ENDIF
	ENDIF
	GOTO 99
C
 85	CONTINUE		! CLEAR BOTH SCREENS
	WRITE(*,1) (CHAR(VCLER(I,ITERM)),I=1,VCLER(7,ITERM))
	WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,GTERM(7,ITERM))
	WRITE(*,1) (CHAR(GCLER(I,ITERM)),I=1,GCLER(7,ITERM))
	WRITE(*,1) (CHAR(VTERM(I,ITERM)),I=1,VTERM(7,ITERM))
	WRITE(*,1) (CHAR(VCLER(I,ITERM)),I=1,VCLER(7,ITERM))
	GOTO 99
C
100	CONTINUE				! TURN GR SCREEN OFF
	WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,GTERM(7,ITERM))
	IF (ITERM.EQ.1) WRITE(*,1) CHAR(ESC),CHAR(39)	! SELNARS (')
	IF (ITERM.EQ.7) WRITE(*,1) CHAR(ESC),CHAR(91),CHAR(48),
     $				   CHAR(35),CHAR(122)	! GRAPHON
	WRITE(*,1) (CHAR(VTERM(I,ITERM)),I=1,VTERM(7,ITERM))
	IMODE=0				! TERMINAL MODE
	GOTO 99
110	CONTINUE				! TURN GR SCREEN ON
	WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,GTERM(7,ITERM))
	IF (ITERM.EQ.1) WRITE(*,1) CHAR(ESC),CHAR(34)	! SELNARS (")
	IF (ITERM.EQ.7) WRITE(*,1) CHAR(ESC),CHAR(91),CHAR(50),
     $				   CHAR(35),CHAR(122)	! GRAPHON
	IMODE=1				! GRAPHICS MODE
	GOTO 99
120	CONTINUE				! CLEAR BOTH SCREENS
	WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,GTERM(7,ITERM))
	WRITE(*,1) (CHAR(GCLER(I,ITERM)),I=1,GCLER(7,ITERM))
	WRITE(*,1) (CHAR(VTERM(I,ITERM)),I=1,VTERM(7,ITERM))
	WRITE(*,1) (CHAR(VCLER(I,ITERM)),I=1,VCLER(7,ITERM))
	IMODE=0				! TERMINAL MODE
	GOTO 99
130	CONTINUE				! DUMP GRAPHICS TO PRINTER
	WRITE(*,1) (CHAR(GTERM(I,ITERM)),I=1,GTERM(7,ITERM))
CC	IF (ITERM.EQ.1) WRITE(*,1) CHAR(ESC),CHAR(59),CHAR(ESC),CHAR(58)! SELNARS
	WRITE(*,1) CHAR(ESC),CHAR(23) ! VT125,VT240,VT220,AND TEKS
	IMODE=1				! GRAPHICS MODE
	GOTO 99
180	CONTINUE			! DE-INITIALIZE GRAPHICS TERMINAL
C
C	COMMAND SEQUENCES TO RESTORE TERMINAL TO NOMINAL OPERATION MODE
C
	WRITE(*,1) (CHAR(VTERM(I,ITERM)),I=1, VTERM(7,ITERM))
	IMODE=0				! TERMINAL MODE
	IF (ITERM.EQ.3) WRITE(*,1) (CHAR(VTERM(I,ITERM)),I=1,6)	! VT240
C					! SELECT ANSI MODE FOR TEK4107
	IF (ITERM.EQ.6) WRITE(*,1) CHAR(ESC),CHAR(37),CHAR(33),CHAR(49)
	GOTO 99
	END
C
C
	SUBROUTINE PLOTVT(XA,YA,IA)
C
C	PLOT TO TERMINAL GRAPHICS SCREEN
C	USING VTPLOT VECTOR STRING LINE PLOTTING SUBROUTINE
C	FORTRAN-77 VERSION:	DGL JULY 1987
C	MODIFIED:		DGL JUNE 1990
C
C XA	X COORDINATE
C YA	Y COORDINATE
C IA	PEN CONTROL
C     +999   END PLOTTING
C      +11   END PLOTTING
C	+9   ERASE TO (XA,YA) PEN DOWN (DRAW IN BACKGROUND INDEX COLOR)
C	+6   SET RELATIVE ROTATION ANGLE TO XA. PEN UNCHANGED.
C	+5   PEN UP AT CURRENT POINT
C	+4   SET UPPER RIGHT CORNER OF VIEW PORT
C	+3   MOVE TO (XA,YA) PEN UP
C	+2   MOVE TO (XA,YA) PEN DOWN
C	 0   CLEAR SCREEN WHEN XA < 0
C	     SET PEN COLOR WHEN XA >= 0 AND XA < 999
C	     SET TO XOR (NOT AVAILABLE ON ALL DEVICES) WHEN XA=999
C	-2   MOVE TO (XA,YA) PEN DOWN. SET ORIGIN TO (XA,YA)
C	-3   MOVE TO (XA,YA) PEN UP.   SET ORIGIN TO (XA,YA)
C	-4   SET LOWER LEFT CORNER OF VIEW PORT
C	-9   ERASE TO (XA,YA) PEN DOWN. SET ORIGIN TO (XA,YA)
C
C	ANY OTHER VALUE OF IA IS TREATED AS A NOP
C
	INTEGER IC0(13),IV(2)
	REAL AV(2),XVS(2)
	LOGICAL PEN
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	SAVE /VT100/,PEN,IE,X0,Y0
C
C	EQUIVALENCES ARE USED ONLY FOR CONVENIENCE
C
	EQUIVALENCE(AV(1),AV1),(AV(2),AV2),(XVS(1),XV2),(XVS(2),YV2)
	EQUIVALENCE(IV(1),IV1),(IV(2),IV2)
	DATA NC0/13/,IC0/2,3,0,-2,-3,5,11,9,-4,4,999,-9,6/
	DATA PEN/.FALSE./	! START PEN UP
	DATA IE/0/		! PEN TYPE (XOR,ERASE,WRITE) DEF=WRITE
	data x0,y0/0.,0./
C       
	IF (IVT100.LE.0) RETURN
	I0=IA
	TANG=VANG*.017453294
	AV1=XA*COS(TANG)-YA*SIN(TANG)
	AV2=XA*SIN(TANG)+YA*COS(TANG)
	AV1=VSF*AV1+VOX
	AV2=VSF*AV2+VOY
C
C	DECODE INPUT COMMAND
C
	DO 30 I1=1,NC0
		IF (I0.EQ.IC0(I1)) GOTO 40
30	CONTINUE
	GOTO 800
40	GOTO(100,100,75,100,100,50,50,100,70,70,50,100,85),I1
C
C	PEN UP IN PLACE AND TERMINATE PLOTTING COMMANDS
C
50	CONTINUE				! FINISH UP LAST BUFFER
	IF (.NOT.PEN.OR.NIMV.EQ.0) GOTO 60	! EMPTY BUFFER?
	CALL VTPLOT(NIMV,IMV,IE,MVW)		! PLOT IT
60	CONTINUE
	IF (I0.EQ.11.OR.I0.EQ.999) THEN
		CALL CTERM(1)			! RESTORE TERMINAL TO TEXT MODE
		CALL CTERM(8)			! DE-INITIALIZE GRAPHICS
		IVT100=-1			! DISABLE TERMINAL GRAPHICS
	ENDIF
	IF (NIMV.GT.1) THEN
		NIMV1=2*NIMV-1
		IMV(1)=IMV(NIMV1)
		IMV(2)=IMV(NIMV1+1)
		NIMV=1
	ENDIF
	PEN=.FALSE.
	RETURN
C
C	CHANGE VIEWPORT VALUES
C
70	CONTINUE
	AV1=AV1/VRE(1)
	AV2=AV2/VRE(2)
C
C	INSURE VIEWPORT VALUES DO NOT EXCEED HARDWARE WINDOW LIMITS
C
	IF (AV1.LT.0.0) AV1=0.0
	IF (AV1.GT.VLIM(1)) AV1=VLIM(1)
	IF (AV2.LT.0.0) AV1=0.0
	IF (AV2.GT.VLIM(2)) AV2=VLIM(2)
C
	IF (I0.GT.0) THEN
		VVP(3)=AV1
		VVP(4)=AV2
	ELSE
		VVP(1)=AV1
		VVP(2)=AV2
	ENDIF
	RETURN
C
C	CHANGE COLOR/CLEAR SCREEN
C
75	CONTINUE
	IF (XA.GE.0.) GOTO 80
C
C	CLEAR SCREEN AND PEN UP
C
	CALL CTERM(-3)
	PEN=.FALSE.
	NIMV=1
	IMV(1)=0
	IMV(2)=0
	RETURN
80	IF (PEN) CALL VTPLOT(NIMV,IMV,IE,MVW)	! PLOT LAST BUFFER
	IE=0
	IF (XA.NE.999.) THEN
		IVCOL=ifix(XA)
		CALL NEWVCOL(IVCOL)	! CHANGE LINE COLOR
		IF (IVCOL.EQ.0) IE=2	! SET ERASE FLAG
	ELSE
		IE=1			! SET XOR LINE MODE
	ENDIF
	NIMV1=2*NIMV+1
	IMV(1)=IMV(NIMV1)
	IMV(2)=IMV(NIMV1+1)
	NIMV=1
	PEN=.FALSE.
	RETURN
85	CONTINUE
	VANG=VANG+XA			! PLOT ANGLE
	RETURN
C
C	PEN MOTION COMMAND
C
100	CONTINUE			! MOVE PEN
	IF (IA.GT.0) GOTO 200
	VOX=AV1
	VOY=AV2
200	CONTINUE
	I0=IABS(I0)
	IF (I0.EQ.9) THEN
		IF (PEN) CALL VTPLOT(NIMV,IMV,IE,MVW)	! PLOT LAST BUFFER
		NIMV1=2*NIMV+1
		IMV(1)=IMV(NIMV1)
		IMV(2)=IMV(NIMV1+1)
		NIMV=1
		PEN=.FALSE.
	ENDIF
	XM=VVP(1)*VRE(1)
	YM=VVP(2)*VRE(2)
	XX=VVP(3)*VRE(1)
	YX=VVP(4)*VRE(2)
C
C	GET CLIP FLAGS
C
	IVTA=IPCLIP(AV1,AV2,XM,YM,XX,YX)
	IVTB=IPCLIP(X0,Y0,XM,YM,XX,YX)
	XV2=AV1
	YV2=AV2
	IF (IOR(IVTA,IVTB).EQ.0) GOTO 220	! LINE VISIBLE
	IF (IAND(IVTA,IVTB).NE.0) THEN		! LINE INVISIBLE
		I0=3
		GOTO 250
	ENDIF
C
C CLIP LINE
C
	IF (IVTB.NE.0) THEN			! OLD POINT IS OUTSIDE WINDOW
		XV2=X0
		YV2=Y0
		IF (PEN) THEN
			CALL VTPLOT(NIMV,IMV,IE,MVW)
			NIMV=0
			PEN=.FALSE.
		ENDIF
		CALL CLPIT(IVTB,XV2,YV2,AV1,AV2,XM,YM,XX,YX)
		IF (IVTB.NE.0) THEN
			I0=3
			NIMV=0
			X0=AV1
			Y0=AV2
			PEN=.FALSE.
			RETURN
		ENDIF
		IF (I0.EQ.2.OR.I0.EQ.9) THEN
			DO 205 I1=1,2
				T=XVS(I1)/VRE(I1)
				IF (T.LT.0.0) T=0.0
				IF (T.GT.VLIM(I1)) T=VLIM(I1)
				IV(I1)=int(T)
205			CONTINUE
			IF (IYREV.EQ.1) IV(2)=IYLIM-IV(2)
			NIMV=1
			IMV(1)=IV(1)
			IMV(2)=IV(2)
			PEN=.TRUE.
		ENDIF
	ENDIF
	XV=AV1
	YV=AV2
	IF (IVTA.NE.0) CALL CLPIT(IVTA,XV,YV,X0,Y0,XM,YM,XX,YX)
	IF (IVTA.NE.0) THEN
		IF (PEN) THEN
			CALL VTPLOT(NIMV,IMV,IE,MVW)
			PEN=.FALSE.
		ENDIF
		I0=3
		NIMV=0
		X0=AV1
		Y0=AV2
		RETURN
	ENDIF
	XV2=XV
	YV2=YV
C
220	DO 710 I1=1,2
		T=XVS(I1)/VRE(I1)
		IF (T.LT.0.0) T=0.0
		IF (T.GT.VLIM(I1)) T=VLIM(I1)
		IV(I1)=int(T)
710	CONTINUE
	IF (IYREV.EQ.1) IV(2)=IYLIM-IV(2) 		! MOVE ORIGIN
250	X0=AV1
	Y0=AV2
	IF (I0.EQ.2) GOTO 500
	IF (.NOT.PEN) GOTO 400
	IF (I0.EQ.9) THEN
		CALL VTPLOT(NIMV,IMV,2,MVW)
	ELSE
		CALL VTPLOT(NIMV,IMV,IE,MVW)
	ENDIF
400	IMV(1)=IV(1)
	IMV(2)=IV(2)
	NIMV=1
	PEN=.FALSE.
	RETURN
450	IMV(3)=IV(1)
	IMV(4)=IV(2)
	NIMV=2
	PEN=.TRUE.
	RETURN
500	CONTINUE			! PEN DOWN MOVEMENT
	IF (.NOT.PEN) GOTO 450
	PEN=.TRUE.
	NIMV1=2*NIMV+1
	IF (NIMV1.LT.33) GOTO 550
	CALL VTPLOT(NIMV,IMV,IE,MVW)
	IMV(1)=IMV(31)
	IMV(2)=IMV(32)
	NIMV=1
	NIMV1=3
550	IMV(NIMV1)=IV(1)
	IMV(NIMV1+1)=IV(2)
	NIMV=NIMV+1
800	RETURN
	END
C
C
	SUBROUTINE CLPIT(IVTB,XV2,YV2,AV1,AV2,XM,YM,XX,YX)
C
C	CLIPS A LINE SEGMENT PARTIALY VISIBLE
C
	IF (IAND(IVTB,1).NE.0) THEN	! LEFT EDGE
		if (av1.ne.xv2) YV2=YV2+(AV2-YV2)*(XM-XV2)/(AV1-XV2)
		XV2=XM
		IVTB=IPCLIP(XV2,YV2,XM,YM,XX,YX)
	ENDIF
	IF (IAND(IVTB,2).NE.0) THEN	! RIGHT EDGE
		if (av1.ne.xv2) YV2=YV2+(AV2-YV2)*(XX-XV2)/(AV1-XV2)
		XV2=XX
		IVTB=IPCLIP(XV2,YV2,XM,YM,XX,YX)
	ENDIF
	IF (IAND(IVTB,4).NE.0) THEN	! BOTTOM EDGE
		if (av2.ne.yv2) XV2=XV2+(AV1-XV2)*(YM-YV2)/(AV2-YV2)
		YV2=YM
		IVTB=IPCLIP(XV2,YV2,XM,YM,XX,YX)
	ENDIF
	IF (IAND(IVTB,8).NE.0) THEN	! TOP EDGE
		if (av2.ne.yv2) XV2=XV2+(AV1-XV2)*(YX-YV2)/(AV2-YV2)
		YV2=YX
		IVTB=IPCLIP(XV2,YV2,XM,YM,XX,YX)
	ENDIF
	RETURN
	END
C
C
	SUBROUTINE PPLOT(XA,YA,IA)
C
C	FORTRAN-77 VERSION:   	DGL JULY 1987
C	MODIFIED:		DGL JUNE 1990
C
C	PLOT TO PRINTER GRAPHICS FILE
C
C XA	X COORDINATE
C YA	Y COORDINATE
C IA	PEN CONTROL
C	+999 END OF PLOTS
C	+11  END OF PLOTS
C	+10  EJECT PAGE
C	+9   MOVE TO (XA,YA) ERASE
C	+3   MOVE TO (XA,YA) PEN UP
C	+6   CHANGE RELATIVE ROTATION ANGLE TO XA. PEN UNCHANGED
C	+5   PEN UP AT CURRENT LOCATION
C	+4   SET UPPER RIGHT CORNER OF VIEW PORT
C	+2   MOVE TO (XA,YA) PEN DOWN
C	 0   CHANGE PLOTTING COLOR TO XA IF XA >= 0
C	-2   MOVE TO (XA,YA) PEN DOWN SET ORIGIN TO (XA,YA)
C	-3   MOVE TO (XA,YA) PEN UP   SET ORIGIN TO (XA,YA)
C	-4   SET LOWER LEFT CORNER OF VIEW PORT
C	-9   MOVE TO (XA,YA) ERASE    SET ORIGIN TO (XA,YA)
C
C	ANY OTHER VALUE OF IA IS TREATED AS A NOP
C
	INTEGER IV(2),IC0(14)
	REAL AV(2),XVS(2),ALIM(2),ALIM1,ALIM2
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
C
C	EQUIVALENCES ARE USED ONLY FOR CONVENIENCE
C
	EQUIVALENCE (AV(1),AV1),(AV(2),AV2)
	EQUIVALENCE (XVS(1),XV2),(XVS(2),YV2)
	EQUIVALENCE (IV(1),IV1),(IV(2),IV2)
	EQUIVALENCE (ALIM1,ALIM(1)),(ALIM2,ALIM(2))
C
C	META FILE LIMITS ON X AND Y IN INCHES
C
	DATA ALIM/32.7,32.7/
C
	DATA NC0/14/,IC0/2,3,0,-2,-3,5,9,-9,10,11,999,4,-4,6/
C
	IF (LU.LE.0) RETURN
	I0=IA
	TANG=PANG*.0174532
	AV1=XA*COS(TANG)-YA*SIN(TANG)
	AV2=XA*SIN(TANG)+YA*COS(TANG)
	AV1=SF*AV1+OX
	AV2=SF*AV2+OY
C
C	DECODE COMMAND
C
	DO 30 I1=1,NC0
		IF (I0.EQ.IC0(I1)) GOTO 40
30	CONTINUE
	RETURN
40	CONTINUE
	GOTO (100,100,50,100,100,910,100,100,715,900,900,70,70,85),I1
50	CONTINUE
C
C	CHANGE COLOR TO XA
C
	IF (XA.GE.0) THEN
C
C	CHANGE PLOT COLOR
C
		MCOL=ifix(XA)
		CALL PPLOTP(MW,MCOL,1002)
	ENDIF
	RETURN
70	CONTINUE
	IF (AV1.LT.0.0) AV1=0.0
	IF (AV1.GT.ALIM1) AV1=ALIM1
	IF (AV2.LT.0.0) AV2=0.0
	IF (AV2.GT.ALIM2) AV2=ALIM2
	IF (I0.GT.0) THEN
		PVP(3)=AV1
		PVP(4)=AV2
	ELSE
		PVP(1)=AV1
		PVP(2)=AV2
	ENDIF
	RETURN
C
C	CHANGE PLOTTING ANGLE BY XA
C
85	CONTINUE
	PANG=PANG+XA
	RETURN
C
C	DRAW LINE SEGMENT
C
100	CONTINUE
	IF (IA.LE.0) THEN
		OX=AV1
		OY=AV2
	ENDIF
	I0=IABS(I0)
	XM=PVP(1)
	YM=PVP(2)
	XX=PVP(3)
	YX=PVP(4)
	IVTA=IPCLIP(AV1,AV2,XM,YM,XX,YX)
	IVTB=IPCLIP(PX,PY,XM,YM,XX,YX)
	IF (IOR(IVTA,IVTB).EQ.0) GOTO 705	! LINE ENTIRELY VISIBLE	
	IF (IAND(IVTA,IVTB).NE.0) THEN		! LINE ENTIRELY INVISIBLE
		PX=AV1
		PY=AV2
		RETURN
	ENDIF
	IF (IVTB.NE.0) THEN			! OLD POINT IS OUTSIDE WINDOW
		XV2=PX
		YV2=PY
		CALL CLPIT(IVTB,XV2,YV2,AV1,AV2,XM,YM,XX,YX)
		IF (IVTB.NE.0) THEN		! VECTOR DOES NOT INTERSECT
			PX=AV1
			PY=AV2
			RETURN
		ENDIF
		DO 701 I1=1,2
			IF (XVS(I1).LT.0.0) XVS(I1)=0.0
			IF (XVS(I1).GT.ALIM(I1)) XVS(I1)=ALIM(I1)
			T=XVS(I1)/RE(I1)
			IV(I1)=int(T)
701		CONTINUE
		CALL PPLOTP(IV2,IV1,3)
	ENDIF
	XV=AV1
	YV=AV2
	IF (IVTA.NE.0) CALL CLPIT(IVTA,XV,YV,PX,PY,XM,YM,XX,YX)
	IF (IVTA.NE.0) THEN
		PX=AV1
		PY=AV2
		RETURN
	ENDIF
	PX=AV1
	PY=AV2
	AV1=XV
	AV2=YV
	GOTO 715
705	PX=AV1
	PY=AV2
715	DO 720 I1=1,2
		IF (AV(I1).LT.0.0) AV(I1)=0.0
		IF (AV(I1).GT.ALIM(I1)) AV(I1)=ALIM(I1)
		T=AV(I1)/RE(I1)
		IV(I1)=int(T)
720	CONTINUE
	CALL PPLOTP(IV2,IV1,I0)
	RETURN
900	CONTINUE			! I0=999 OR I0=11 END PLOTS
	I0=11
	GOTO 715
910	CONTINUE
	I0=3
	AV1=PX
	AV2=PY
	GOTO 715
	END
C
	SUBROUTINE PLOTRM(XA,YA,IA)
C
C	FORTRAN-77 VERSION:	DGL JULY 1987
C	MODIFIED:		DGL JUNE 1990
C
C	PLOT TO RAMTEK USING RMPLOT VECTOR STRING LINE PLOTTING ROUTINE
C
C XA	X COORDINATE
C YA	Y COORDINATE
C IA	PEN CONTROL
C     +999   END PLOTTING
C      +11   END PLOTTING
C	+9   ERASE TO (XA,YA) PEN DOWN (ERASE COLOR IS 0)
C	+6   RELATIVE ROTATION ANGLE SET TO XA. PEN UNCHANGED
C	+5   PEN UP AT CURRENT POSITION
C	+4   SET UPPER RIGHT CORNER OF VIEW PORT
C	+3   MOVE TO (XA,YA) PEN UP
C	+2   MOVE TO (XA,YA) PEN DOWN
C	 0   CLEAR SCREEN WHEN XA < 0
C	     XA >= CHANGE COLOR TABLE VALUE USED FOR PLOTTING TO XA
C	-2   MOVE TO (XA,YA) PEN DOWN SET ORIGIN TO (XA,YA)
C	-3   MOVE TO (XA,YA) PEN UP   SET ORIGIN TO (XA,YA)
C	-4   SET LOWER RIGHT CORNER OF VIEW PORT
C	-9   ERASE TO (XA,YA) PEN DOWN (ERASE COLOR IS 0) SET ORIGIN
C		TO (XA,YA)
C
C	ANY OTHER VALUE OF IA IS TREATED AS A NOP
C
	INTEGER IC0(13),IV(2)
	REAL AV(2),XVS(2)
	LOGICAL PEN
C
	COMMON/RMTEK/ICHAN,IMR(128),RRE(2),ROX,ROY,RSF,NIMR,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/,PEN,X0,Y0
C
C	EQUIVALENCES ARE USED ONLY FOR CONVENIENCE
C
	EQUIVALENCE(AV(1),AV1),(AV(2),AV2),(XVS(1),XV2),(XVS(2),YV2)
	EQUIVALENCE(IV(1),IV1),(IV(2),IV2)
	DATA NC0/13/,IC0/2,3,0,-2,-3,5,11,9,-9,4,-4,999,6/
	DATA ICOL0/0/			! ERASE COLOR
	DATA PEN/.FALSE./	! PEN UP FLAG
	data x0,y0/0.,0./
C
	IF (ICHAN.LE.0) RETURN
	I0=IA
	TANG=RANG*.0174532
	AV1=XA*COS(TANG)-YA*SIN(TANG)
	AV2=XA*SIN(TANG)+YA*COS(TANG)
	AV1=RSF*AV1+ROX
	AV2=RSF*AV2+ROY
C
C	DECODE COMMAND
C
	DO 30 I1=1,NC0
		IF (I0.EQ.IC0(I1)) GOTO 40
30	CONTINUE
	GOTO 800
40	CONTINUE
	GOTO(100,100,75,100,100,50,50,80,80,70,70,50,95),I1
50	CONTINUE				! FINISH UP LAST BUFFER
	IF (.NOT.PEN.OR.NIMR.EQ.0) GOTO 60	! EMPTY BUFFER
	CALL RMPLOT(ICHAN,NIMR,IMR,ICOL,IERR)	! PLOT IT
60	IF (I0.NE.5) CALL RAMCLOSE(ICHAN)	! CLOSE RAM TEK CHANNEL
	IF (NIMR.GT.1) THEN
		NIMR1=2*NIMR-1
		IMR(1)=IMR(NIMR1)
		IMR(2)=IMR(NIMR1+1)
		NIMR=1
	ENDIF
	PEN=.FALSE.
	RETURN
70	AV1=AV1/RRE(1)
	AV2=AV2/RRE(2)
	IF (AV1.LT.0.0) AV1=0.0
	IF (AV1.GT.RLIM(1)) AV1=RLIM(1)
	IF (AV2.LT.0.0) AV1=0.0
	IF (AV2.GT.RLIM(2)) AV2=RLIM(2)
	IF (I0.GT.0) THEN
		RVP(3)=AV1
		RVP(4)=AV2
	ELSE
		RVP(1)=AV1
		RVP(2)=AV2
	ENDIF
	RETURN
75	CONTINUE			! CHANGE COLOR TABLE VALUE
	IF (XA.GE.0.) GOTO 80
	CALL RMCLEAR(ICHAN,IERR)	! CLEAR RAM TEK SCREEN
	PEN=.FALSE.
	NIMR=1
	IMR(1)=0
	IMR(2)=0
	RETURN
80	IF (.NOT.PEN) GOTO 90
	CALL RMPLOT(ICHAN,NIMR,IMR,ICOL,IERR)! PLOT LAST BUFFER
	NIMR1=2*NIMR+1
	IMR(1)=IMR(NIMR1)
	IMR(2)=IMR(NIMR1+1)
	NIMR=1
90	CONTINUE	
	IF (I0.EQ.9) THEN		! ERASE LINE
		PEN=.TRUE.
		GOTO 100
	ENDIF
	IF (XA.LT.1024.) ICOL=int(XA)
	IF (ICOL.LT.0) ICOL=0
	PEN=.FALSE.			! PEN UP
	RETURN
95	CONTINUE			! ROTATION ANGLE
	RANG=RANG+XA
	RETURN
100	CONTINUE			! MOVE PEN
	IF (IA.GT.0) GOTO 200
	ROX=AV1
	ROY=AV2
200	CONTINUE
	I0=IABS(I0)
	XM=RVP(1)*RRE(1)
	YM=RVP(2)*RRE(2)
	XX=RVP(3)*RRE(1)
	YX=RVP(4)*RRE(2)
	IVTA=IPCLIP(AV1,AV2,XM,YM,XX,YX)
	IVTB=IPCLIP(X0,Y0,XM,YM,XX,YX)
	XV2=AV1
	YV2=AV2
	IF (IOR(IVTA,IVTB).EQ.0) GOTO 220	! LINE VISIBLE
	IF (IAND(IVTA,IVTB).NE.0) THEN		! LINE INVISIBLE
		I0=3
		GOTO 250
	ENDIF
C
C CLIP LINE
C
	IF (IVTB.NE.0) THEN			! OLD POINT IS OUTSIDE WINDOW
		XV2=X0
		YV2=Y0
		IF (PEN) THEN
			CALL RMPLOT(ICHAN,NIMR,IMR,ICOL,IERR)! PLOT LAST BUFFER
			NIMR=0
			PEN=.FALSE.
		ENDIF
		CALL CLPIT(IVTB,XV2,YV2,AV1,AV2,XM,YM,XX,YX)
		IF (IVTB.NE.0) THEN
			I0=3
			NIMR=0
			X0=AV1
			Y0=AV2
			PEN=.FALSE.
			RETURN
		ENDIF
		IF (I0.EQ.2.OR.I0.EQ.9) THEN
			DO 205 I1=1,2
				T=XVS(I1)/RRE(I1)
				IF (T.LT.0.0) T=0.0
				IF (T.GT.RLIM(I1)) T=RLIM(I1)
				IV(I1)=int(T)
205			CONTINUE
			IV(2)=IRYLIM-IV(2)
			NIMR=1
			IMR(1)=IV(1)
			IMR(2)=IV(2)
			PEN=.TRUE.
		ENDIF
	ENDIF
	XV=AV1
	YV=AV2
	IF (IVTA.NE.0) CALL CLPIT(IVTA,XV,YV,X0,Y0,XM,YM,XX,YX)
	IF (IVTA.NE.0) THEN
		IF (PEN) THEN
			CALL RMPLOT(ICHAN,NIMR,IMR,ICOL,IERR)! PLOT LAST BUFFER
			PEN=.FALSE.
		ENDIF
		I0=3
		NIMR=0
		X0=AV1
		Y0=AV2
		RETURN
	ENDIF
	XV2=XV
	YV2=YV
C
220	DO 710 I1=1,2
		T=XVS(I1)/RRE(I1)
		IF (T.LT.0.0) T=0.0
		IF (T.GT.RLIM(I1)) T=RLIM(I1)
		IV(I1)=int(T)
710	CONTINUE
	IV(2)=IRYLIM-IV(2) 		! MOVE ORIGIN
250	X0=AV1
	Y0=AV2
	IF (I0.EQ.2) GOTO 500
	IF (.NOT.PEN) GOTO 400
	IF (I0.NE.9) THEN
		CALL RMPLOT(ICHAN,NIMR,IMR,ICOL,IERR)! PLOT LAST BUFFER
	ELSE
		IMR(3)=IV(1)
		IMR(4)=IV(2)
		CALL RMPLOT(ICHAN,2,IMR,ICOL0,IERR)! PLOT ERASE LINE
	ENDIF
400	IMR(1)=IV(1)
	IMR(2)=IV(2)
	NIMR=1
	PEN=.FALSE.
	RETURN
450	IMR(3)=IV(1)
	IMR(4)=IV(2)
	NIMR=2
	PEN=.TRUE.
	RETURN
500	CONTINUE			! PEN DOWN MOVEMENT
	IF (.NOT.PEN) GOTO 450
	PEN=.TRUE.
	NIMR1=2*NIMR+1
	IF (NIMR1.LT.129) GOTO 550
	CALL RMPLOT(ICHAN,NIMR,IMR,ICOL,IERR)! PLOT BUFFER
	IMR(1)=IMR(127)
	IMR(2)=IMR(128)
	NIMR=1
	NIMR1=3
550	IMR(NIMR1)=IV(1)
	IMR(NIMR1+1)=IV(2)
	NIMR=NIMR+1
800	RETURN
	END
C
C
	INTEGER FUNCTION IPCLIP(X,Y,XM,YM,XX,YX)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	CHECKS TO SEE IF POINT XY IS IN RECTANGLE (XM,YM)-(XX,YX)
C	RETURNS ZERO IF IT IS
C
	INTEGER CD
	CD=0
	IF (X.LT.XM) THEN
		CD=1
	ELSE
		IF (X.GT.XX) CD=2
	ENDIF
	IF (Y.LT.YM) THEN
		CD=CD+4
	ELSE
		IF (Y.GT.YX) CD=CD+8
	ENDIF
	IPCLIP=CD
	RETURN
	END
C
C
	SUBROUTINE RPLOTS(ID,VPX,VPY,ZOM)
C
C	FORTRAN-77 VERSION:	DGL JULY, 1987
C	SIZE SPECIFIED VERSION:	DGL MAY, 1993
C
C	THIS ROUTINE INTIALIZES THE RAMTEK GRAPHICS DEVICE
C
C	ID	SCREEN CONTROL
C		<= 0 CLEAR SCREEN ON OPEN
C		= 1 NORMAL (1280X1024) RAMTEK [DEFAULT] WIDE=11"
C		= 2 SMALL RAMTEK (512X512) WIDE=11"
C		= 3 384X256 WIDE=7"
C		= 4 768X512 WIDE=7"
C		= 5 256X172 WIDE=7"
C		= 101 CUSTOM SIZE.  THEN ID(2)=X SIZE, ID(3)=Y SIZE, ID(4)=WIDE
C	VPX,VPY	ORIGIN IN INCHES
C	ZOM	SCALE FACTOR
C		< 0 SMALL RAMTEK (512X512) WIDE=11"
C
	DIMENSION ID(4)
C
	COMMON/RMTEK/ICHAN,IMR(128),RRE(2),ROX,ROY,RSF,NIMR,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
C
	IID=ID(1)
	IRID=MOD(IABS(IID),100)	! NORMAL RAMTEK (1280X1024)
	IF (ZOM.LT.0.0) IRID=2	! SMALL RAMTEK (512X512)
	MM=0			! LINE TYPE
	IPW=1			! LINE WIDTH
	IPSC=0			! LINE TYPE SCALE FACTOR
	NIMR=1			! RESET VECTOR BUFFTER
	IMR(1)=0		! ORIGIN VECTOR BUFFER
	IMR(2)=0		! ORIGIN VECTOR BUFFER
	ICOL=255		! DEFAULT COLOR TABLE VALUE
	ROX=VPX 		! X ORIGIN
	ROY=VPY 		! Y ORIGIN
	RSF=ABS(ZOM)		! SCALE RACTOR
	RANG=0.			! ROTATION
	IF (RSF.LE.0.0) RSF=1.0
	RRE(1)=1024.
	RLIM(1)=1279.
	WIDE=11.0
	IF (IRID.EQ.2) THEN
		RRE(1)=512.
		RLIM(1)=511.
	ELSE IF (IRID.EQ.3) THEN
		WIDE=7.0
		RRE(1)=256.0
		RLIM(1)=384.0
	ELSE IF (IRID.EQ.4) THEN
		IRID=3
		WIDE=7.0
		RRE(1)=512.0
		RLIM(1)=768.0
	ELSE IF (IRID.EQ.5) THEN
		IRID=3
		WIDE=7.0
		RRE(1)=172.0
		RLIM(1)=256.0
	ENDIF
C
	IF (IABS(IID).GT.100) THEN ! SET CUSTOM SIZE (ONLY USEFUL ON SOME DEVICES)
		IRID=4
		WIDE=ID(4)
		RRE(1)=ID(3)
		RLIM(1)=ID(2)
	ENDIF
C
	IERR=int(RRE(1))
	IDDEV=int(RLIM(1)+1.05)
	RLIM(2)=RRE(1)-1.
	IRXLIM=int(RLIM(1))
	IRYLIM=int(RLIM(2))
	RRE(1)=WIDE/RRE(1)	! BIG RAM TEK RESOLUTION X (1024 PIXELS IN 11 INCHES)
	RRE(2)=RRE(1)		! RAMTEK RESOLUTION Y
	RVP(1)=0.0		! VIEW PORT PARAMETERS
	RVP(2)=0.0		! LOWER LEFT
C
C	OPEN UP RAMTEK DISPLAY
C
	ICH=IABS(IID)/100		! WINDOW NUMBER FOR RAMXLIB
	IF (ICH.EQ.0) ICH=1
	CALL RAMOPEN(ICH,IRID,IDDEV,IERR)	! OPEN RAMTEK CHANNEL
	IF (ICH.LT.0.OR.IERR.NE.0) THEN		! RAMTEK NOT AVAILABLE
		WRITE (*,1)
1		FORMAT(' *** RAMTEK NOT AVAILABLE ***')
		CALL EXIT(0)
	ENDIF
	ICHAN=ICH
C
C	TEST FOR CUSTOM DISPLAY SIZE
C
	IF (IABS(IID).GT.100) THEN
		IF (IDDEV.NE.ID(2).OR.IERR.NE.ID(3)) THEN
			WRITE (*,2) ID(2),ID(3),IDDEV,IERR
2			FORMAT( ' *** RPLOTS: Ramtek desired size: ',2I6/
     $				' *** RPLOTS: Ramtek returned size:',2I6)
CC			RRE(1)=IERR
CC			RLIM(1)=IDDEV
CC			RLIM(2)=RRE(1)-1.
CC			IRXLIM=RLIM(1)
CC			IRYLIM=RLIM(2)
CC			RRE(1)=WIDE/RRE(1)
CC			RRE(2)=RRE(1)
		ENDIF
	ENDIF
C
	CALL RMTEXTURE(ICHAN,MM,IPW,IPSC,IERR) ! SET LINE TEXTURE
	CALL PLOTRM(999.,999.,4)! UPPER RIGHT
	IF (IID.LE.0) CALL PLOTRM(-1.,0.,0)			! CLEAR SCREEN
	RETURN
	END
C
C
	INTEGER FUNCTION IRMCHAN(IDEV)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	RETURNS RAMTEK CHANNEL NUMBER IN CURRENT USE
C	A VALUE LESS THAN 1 INDICATES THAT CHANNEL IS NOT OPEN
C
C	OUTPUTS:
C	IDEV	(I)	RAMTEK DEVICE NUMBER
C
	COMMON/RMTEK/ICHAN,IMR(128),RRE(2),ROX,ROY,RSF,NIMR,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
	IRMCHAN=ICHAN
	IDEV=IDDEV
	RETURN
	END
C
	SUBROUTINE WHERERM(ORX,ORY,ZOM,ANG,RX,RY,NT,NS,ICOLOR,NCHAN)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	RETURNS PLOT INFO FROM RAMTEK
C
	COMMON/RMTEK/ICHAN,IMR(128),RRE(2),ROX,ROY,RSF,NIMR,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
C
	ORX=ROX				! X ORIGIN
	ORY=ROY				! Y ORIGIN
	ZOM=RSF				! ZOOM SCALE FACTOR
	ANG=RANG			! PLOTTING ANGLE
	IF (RSF.NE.0.0) RX=RRE(1)/RSF	! X DIRECTION RESOLUTION
	IF (RSF.NE.0.0) RY=RRE(2)/RSF	! Y DIRECTION RESOLUTION
	NT=MM				! LINE TYPE
	NS=IPW				! PIXEL SCALING OF LINE TYPE
	NCHAN=ICHAN			! CHANNEL NUMBER IF NCHAN > 0
	ICOLOR=ICOL			! CURRENT COLOR TABLE VALUE
	RETURN
	END
C
	SUBROUTINE WHEREVT(ORX,ORY,ZOM,ANG,RX,RY,NVT,ISEL,NT,NW,NCOL)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	RETURNS PLOT INFO FOR TERMINAL
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	SAVE /VT100/
C
	ORX=VOX				! X ORIGIN
	ORY=VOY				! Y ORIGIN
	ZOM=VSF				! ZOOM SCALE FACTOR
	ANG=VANG			! PLOTTING ANGLE
	IF (VSF.NE.0.0) RX=VRE(1)/VSF	! X DIRECTION RESOLUTION
	IF (VSF.NE.0.0) RY=VRE(2)/VSF	! Y DIRECTION RESOLUTION
	NVT=IVT100			! NVT > 0 MEANS VT ENABLED
	ISEL=ITERM			! 0=SELNAR GR1000+ 1=GR100
	NT=MV				! LINE TYPE
	NW=MVW				! LINE WIDTH
	NCOL=IVCOL			! LINE COLOR
	RETURN
	END
C
	SUBROUTINE WHEREPR(ORX,ORY,AX,AY,ZOM,ANG,RX,RY,NVT,MXX,MWW,MCOLL)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	RETURNS PLOT INFO FROM PRINTER
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
C
	ORX=OX				! X ORIGIN
	ORY=OY				! Y ORIGIN
	AX=PX				! LAST SCALED,SHIFTED X
	AY=PY				! LAST SCALED,SHIFTED Y
	ZOM=SF				! ZOOM SCALE FACTOR
	ANG=PANG			! PLOTTING ANGLE
	IF (SF.NE.0.0) RX=RE(1)/SF	! X DIRECTION RESOLUTION
	IF (SF.NE.0.0) RY=RE(2)/SF	! Y DIRECTION RESOLUTION
	NVT=LU				! NVT > 0 MEANS PR ENABLED
	MXX=MX				! LINE TYPE
	MWW=MW				! LINE WIDTH
	MCOLL=MCOL			! LINE COLOR
	RETURN
	END
C
	SUBROUTINE PLOT(XA,YA,I0)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	+ ADD CONTROL-C INTERRUPT
C	  NOTE: IF CONTROL-C CODE IS NOT USED, LINES MARKED WITH CONTROL-C
C	  CAN BE COMMENTED OUT.
C
C	BASIC SUBROUTINE FOR PLOTTING TO ALL DEVICES
C
	COMMON/LSTPLT/XLAST,YLAST,I0LAST
	COMMON/ASTC/IASTFL,IASTPL			! CONTROL-C
C
	IASTPL=1					! CONTROL-C
	CALL PPLOT (XA,YA,I0)
	CALL PLOTRM(XA,YA,I0)
	CALL PLOTVT(XA,YA,I0)
	XLAST=XA
	YLAST=YA
	I0LAST=I0
	IASTPL=0					! CONTROL-C
	IF (IASTFL.NE.0) CALL ASTINTER(IASTFL)	! CONTROL-C
	RETURN
	END
C
C
	SUBROUTINE PFACTOR(SC)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	CHANGE SCALE FACTOR ON PRINTER
C
C	SC	(R)	SCALE FACTOR
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
	IF (SC.GT.0.) SF=SC*SF
	IF (SC.LE.0.) SF=1.
	RETURN
	END
C
	SUBROUTINE RFACTOR(SC)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C	CHANGE SCALE FACTOR ON RAMTEK DISPLAY
C
	COMMON/RMTEK/ICHAN,IMR(128),RRE(2),ROX,ROY,RSF,NIMR,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
	IF (SC.GT.0.) RSF=RSF*SC
	IF (SC.LE.0.) RSF=1.
	RETURN
	END
C
	SUBROUTINE VFACTOR(SC)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C	CHANGE SCALE FACTOR FOR TERMINAL PLOTTING
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	SAVE /VT100/
	IF (SC.GT.0.) VSF=VSF*SC
	IF (SC.LE.0.) VSF=1.
	RETURN
	END
C
C
	SUBROUTINE METMAP(IARRAY,NA,MA,N,M,XLL,YLL,XUR,YUR)
C
C	MAKE IMAGE MAP ON META FILE
C
C	AUTHOR: DG LONG, JPL
C	DATE: 25 JAN 1991
C
C	INPUTS:
C	  IARRAY  : COLOR CODES
C	  NA,MA	  : DIMENSIONS OF IARRAY
C	  N,M	  : PLOT N BY M PORTION OF IARRAY (0 < N,M < 2049)
C	  XLL,YLL : POSITION OF LOWER-LEFT CORNER OF MAP (IN PLOT UNITS)
C	  XLL,YLL : POSITION OF UPPER-RIGHT CORNER OF MAP (IN PLOT UNITS)
C
C	CALLS:
C	  PPLOT
C	  PPLOTP
C
	INTEGER IARRAY(NA,MA)
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
C
C	META FILE LIMITS ON X AND Y IN INCHES
C
	DIMENSION IV(2),AV(2),ALIM(2)
	DATA ALIM/32.7,32.7/
C
	IF (LU.LE.0) RETURN
C
C	ENTER ORIGIN POINT IN METAFILE
C
	CALL PPLOT(XLL,YLL,3)
C
C	ENTER X,Y AXES LENGTHS
C
	XA=XLL
	YA=YLL
	TANG=PANG*.0174532
	AV(1)=XA*COS(TANG)-YA*SIN(TANG)
	AV(2)=XA*SIN(TANG)+YA*COS(TANG)
	AX=SF*AV(1)+OX
	AY=SF*AV(2)+OY
	XA=XUR
	YA=YUR
	TANG=PANG*.0174532
	AV(1)=XA*COS(TANG)-YA*SIN(TANG)
	AV(2)=XA*SIN(TANG)+YA*COS(TANG)
	AV(1)=SF*AV(1)+OX-AX
	AV(2)=SF*AV(2)+OY-AY
C
	DO 720 I1=1,2
		IF (AV(I1).LT.0.0) AV(I1)=0.0
		IF (AV(I1).GT.ALIM(I1)) AV(I1)=ALIM(I1)
		IV(I1)=int(AV(I1)/RE(I1))
720	CONTINUE
	CALL PPLOTP(IV(1),IV(2),2000)
C
	NX=N
	IF (NX.LT.1) NX=1
	IF (NX.GT.2048) NX=2048
	NY=M
	IF (NY.LT.1) NY=1
	IF (NY.GT.2048) NY=2048
	CALL PPLOTP(NX,NY,2001)
C
C	OUTPUT MAP DATA IN Y-MAJOR ORDER, I.E., (1,1) (1,2) (1,3)...
C
	NN=NX*NY
	I2=1
	DO 100 IX=1,NX
	  DO 100 IY=1,NY
C		I1=IX+(IY-1)*NA
		IV(I2)=IARRAY(IX,IY)
		IF (IABS(IV(I2)).GT.32760) IV(I2)=ISIGN(32760,IV(I2))
		I2=I2+1
		IF (I2.EQ.3) THEN
			CALL PPLOTP(IV(1),IV(2),2002)
			I2=1
		ENDIF
100	CONTINUE
	IF (I2.EQ.2) CALL PPLOTP(IV(1),IV(2),2002)
C
	RETURN
	END
C
C
	SUBROUTINE METMAP2(IARRAY,NA,MA,NS,MS,NE,ME,XLL,YLL,XUR,YUR)
C
C	MAKE IMAGE MAP ON META FILE
C
C	AUTHOR: DG LONG, JPL
C	DATE: 25 JAN 1991
C
C	INPUTS:
C	  IARRAY  : COLOR CODES
C	  NA,MA	  : DIMENSIONS OF IARRAY
C	  NS,MS	  : STARTING LOWER-LEFT CORNER ( 0 < NS < NA, 0 < MS < MA)
C	  NE,ME	  : ENDING UPPER-RIGHT CORNER  ( NS <= NS <= NA, MS <= MS <= MA)
C	  	    OF RECTRANGLE TO PLOT (0 < NE-NS, ME-NS < 2048)
C	  XLL,YLL : POSITION OF LOWER-LEFT CORNER OF MAP (IN PLOT UNITS)
C	  XUR,YUR : POSITION OF UPPER-RIGHT CORNER OF MAP (IN PLOT UNITS)
C
C	CALLS:
C	  PPLOT
C	  PPLOTP
C
	INTEGER IARRAY(NA,MA)
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
C
C	META FILE LIMITS ON X AND Y IN INCHES
C
	DIMENSION IV(2),AV(2),ALIM(2)
	DATA ALIM/32.7,32.7/
C
	IF (LU.LE.0) RETURN
C
C	ENTER ORIGIN POINT IN METAFILE
C
	CALL PPLOT(XLL,YLL,3)
C
C	ENTER X,Y AXES LENGTHS
C
	XA=XLL
	YA=YLL
	TANG=PANG*.0174532
	AV(1)=XA*COS(TANG)-YA*SIN(TANG)
	AV(2)=XA*SIN(TANG)+YA*COS(TANG)
	AX=SF*AV(1)+OX
	AY=SF*AV(2)+OY
	XA=XUR
	YA=YUR
	TANG=PANG*.0174532
	AV(1)=XA*COS(TANG)-YA*SIN(TANG)
	AV(2)=XA*SIN(TANG)+YA*COS(TANG)
	AV(1)=SF*AV(1)+OX-AX
	AV(2)=SF*AV(2)+OY-AY
C
	DO 720 I1=1,2
		IF (AV(I1).LT.0.0) AV(I1)=0.0
		IF (AV(I1).GT.ALIM(I1)) AV(I1)=ALIM(I1)
		IV(I1)=int(AV(I1)/RE(I1))
720	CONTINUE
	CALL PPLOTP(IV(1),IV(2),2000)
C
	NX1=NS
	IF (NX1.LT.1) NX1=1
	IF (NX1.GT.2047) NX1=2047
	NX2=NE
	IF (NX2.LT.NX1) NX2=1
	IF (NX2.GT.2048) NX2=2048
	NX=NX2-NX1+1
	NY1=MS
	IF (NY1.LT.1) NY1=1
	IF (NY1.GT.2047) NY1=2047
	NY2=ME
	IF (NY2.LT.NY1) NY2=1
	IF (NY2.GT.2048) NY2=2048
	NY=NY2-NY1+1
	CALL PPLOTP(NX,NY,2001)
C
C	OUTPUT MAP DATA IN Y-MAJOR ORDER, I.E., (1,1) (1,2) (1,3)...
C
	NN=NX*NY
	I2=1
	DO 100 IX=NX1,NX2
	  DO 100 IY=NY1,NY2
		IV(I2)=IARRAY(IX,IY)
		IF (IABS(IV(I2)).GT.32760) IV(I2)=ISIGN(32760,IV(I2))
		I2=I2+1
		IF (I2.EQ.3) THEN
			CALL PPLOTP(IV(1),IV(2),2002)
			I2=1
		ENDIF
100	CONTINUE
	IF (I2.EQ.2) CALL PPLOTP(IV(1),IV(2),2002)
C
	RETURN
	END
C
C
	SUBROUTINE METMAPA(IARRAY,NA,MA,N,M,XLL,YLL,XUR,YUR)
C
C	MAKE IMAGE MAP ON META FILE
C
C	AUTHOR: DG LONG, JPL
C	DATE: 25 JAN 1991
C
C	INPUTS:
C	  IARRAY  : COLOR CODES
C	  NA,MA	  : DIMENSIONS OF IARRAY
C	  N,M	  : PLOT N BY M PORTION OF IARRAY (0 < N,M < 2049)
C	  XLL,YLL : POSITION OF LOWER-LEFT CORNER OF MAP (IN PLOT UNITS)
C	  XLL,YLL : POSITION OF UPPER-RIGHT CORNER OF MAP (IN PLOT UNITS)
C
C	CALLS:
C	  PPLOT
C	  PPLOTP
C
	INTEGER*2 IARRAY(NA,MA)
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
C
C	META FILE LIMITS ON X AND Y IN INCHES
C
	DIMENSION IV(2),AV(2),ALIM(2)
	DATA ALIM/32.7,32.7/
C
	IF (LU.LE.0) RETURN
C
C	ENTER ORIGIN POINT IN METAFILE
C
	CALL PPLOT(XLL,YLL,3)
C
C	ENTER X,Y AXES LENGTHS
C
	XA=XLL
	YA=YLL
	TANG=PANG*.0174532
	AV(1)=XA*COS(TANG)-YA*SIN(TANG)
	AV(2)=XA*SIN(TANG)+YA*COS(TANG)
	AX=SF*AV(1)+OX
	AY=SF*AV(2)+OY
	XA=XUR
	YA=YUR
	TANG=PANG*.0174532
	AV(1)=XA*COS(TANG)-YA*SIN(TANG)
	AV(2)=XA*SIN(TANG)+YA*COS(TANG)
	AV(1)=SF*AV(1)+OX-AX
	AV(2)=SF*AV(2)+OY-AY
C
	DO 720 I1=1,2
		IF (AV(I1).LT.0.0) AV(I1)=0.0
		IF (AV(I1).GT.ALIM(I1)) AV(I1)=ALIM(I1)
		IV(I1)=int(AV(I1)/RE(I1))
720	CONTINUE
	CALL PPLOTP(IV(1),IV(2),2000)
C
	NX=N
	IF (NX.LT.1) NX=1
	IF (NX.GT.2048) NX=2048
	NY=M
	IF (NY.LT.1) NY=1
	IF (NY.GT.2048) NY=2048
	CALL PPLOTP(NX,NY,2001)
C
C	OUTPUT MAP DATA IN Y-MAJOR ORDER, I.E., (1,1) (1,2) (1,3)...
C
	NN=NX*NY
	I2=1
	DO 100 IX=1,NX
	  DO 100 IY=1,NY
C		I1=IX+(IY-1)*NA
		IV(I2)=IARRAY(IX,IY)
		IF (IABS(IV(I2)).GT.32760) IV(I2)=ISIGN(32760,IV(I2))
		I2=I2+1
		IF (I2.EQ.3) THEN
			CALL PPLOTP(IV(1),IV(2),2002)
			I2=1
		ENDIF
100	CONTINUE
	IF (I2.EQ.2) CALL PPLOTP(IV(1),IV(2),2002)
C
	RETURN
	END
C
C
	SUBROUTINE METMAP2A(IARRAY,NA,MA,NS,MS,NE,ME,XLL,YLL,XUR,YUR)
C
C	MAKE IMAGE MAP ON META FILE
C
C	AUTHOR: DG LONG, JPL
C	DATE: 25 JAN 1991
C
C	INPUTS:
C	  IARRAY  : COLOR CODES
C	  NA,MA	  : DIMENSIONS OF IARRAY
C	  NS,MS	  : STARTING LOWER-LEFT CORNER ( 0 < NS < NA, 0 < MS < MA)
C	  NE,ME	  : ENDING UPPER-RIGHT CORNER  ( NS <= NS <= NA, MS <= MS <= MA)
C	  	    OF RECTRANGLE TO PLOT (0 < NE-NS, ME-NS < 2048)
C	  XLL,YLL : POSITION OF LOWER-LEFT CORNER OF MAP (IN PLOT UNITS)
C	  XUR,YUR : POSITION OF UPPER-RIGHT CORNER OF MAP (IN PLOT UNITS)
C
C	CALLS:
C	  PPLOT
C	  PPLOTP
C
	INTEGER*2 IARRAY(NA,MA)
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
C
C	META FILE LIMITS ON X AND Y IN INCHES
C
	DIMENSION IV(2),AV(2),ALIM(2)
	DATA ALIM/32.7,32.7/
C
	IF (LU.LE.0) RETURN
C
C	ENTER ORIGIN POINT IN METAFILE
C
	CALL PPLOT(XLL,YLL,3)
C
C	ENTER X,Y AXES LENGTHS
C
	XA=XLL
	YA=YLL
	TANG=PANG*.0174532
	AV(1)=XA*COS(TANG)-YA*SIN(TANG)
	AV(2)=XA*SIN(TANG)+YA*COS(TANG)
	AX=SF*AV(1)+OX
	AY=SF*AV(2)+OY
	XA=XUR
	YA=YUR
	TANG=PANG*.0174532
	AV(1)=XA*COS(TANG)-YA*SIN(TANG)
	AV(2)=XA*SIN(TANG)+YA*COS(TANG)
	AV(1)=SF*AV(1)+OX-AX
	AV(2)=SF*AV(2)+OY-AY
C
	DO 720 I1=1,2
		IF (AV(I1).LT.0.0) AV(I1)=0.0
		IF (AV(I1).GT.ALIM(I1)) AV(I1)=ALIM(I1)
		IV(I1)=int(AV(I1)/RE(I1))
720	CONTINUE
	CALL PPLOTP(IV(1),IV(2),2000)
C
	NX1=NS
	IF (NX1.LT.1) NX1=1
	IF (NX1.GT.2047) NX1=2047
	NX2=NE
	IF (NX2.LT.NX1) NX2=1
	IF (NX2.GT.2048) NX2=2048
	NX=NX2-NX1+1
	NY1=MS
	IF (NY1.LT.1) NY1=1
	IF (NY1.GT.2047) NY1=2047
	NY2=ME
	IF (NY2.LT.NY1) NY2=1
	IF (NY2.GT.2048) NY2=2048
	NY=NY2-NY1+1
	CALL PPLOTP(NX,NY,2001)
C
C	OUTPUT MAP DATA IN Y-MAJOR ORDER, I.E., (1,1) (1,2) (1,3)...
C
	NN=NX*NY
	I2=1
	DO 100 IX=NX1,NX2
	  DO 100 IY=NY1,NY2
		IV(I2)=IARRAY(IX,IY)
		IF (IABS(IV(I2)).GT.32760) IV(I2)=ISIGN(32760,IV(I2))
		I2=I2+1
		IF (I2.EQ.3) THEN
			CALL PPLOTP(IV(1),IV(2),2002)
			I2=1
		ENDIF
100	CONTINUE
	IF (I2.EQ.2) CALL PPLOTP(IV(1),IV(2),2002)
C
	RETURN
	END
C
	SUBROUTINE METCOL(IRED,IGRN,IBLU,ICOD,N)
C
C	DUMP COLOR TABLE DATA TO META FILE
C
C	IRED,IGRN,IBLU	(I)	RGB VALUES FOR COLOR TABLE INDEXES
C	ICOD		(I)	CODE VALUE
C	N		(I)	NUMBER OF ENTRIES (0 < N < 1025)
C
	DIMENSION IRED(1),IGRN(1),IBLU(1),ICOD(1)
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
C
	IF (LU.LE.0) RETURN
	N1=N
	IF (N1.LT.1) RETURN
	IF (N1.GT.1024) N1=1024
	CALL PPLOTP(N1,0,2010)
	DO 10 I=1,N1
		CALL PPLOTP(IRED(I),IGRN(I),2011)
		CALL PPLOTP(IBLU(I),ICOD(I),2012)
10	CONTINUE
	RETURN
	END	
C
C
	SUBROUTINE PPLOTP(M0,M1,M2)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	WRITE PLOTTING DATA TO META FILE
C
C M0	WORD 1 OF OUTPUT
C M1	WORD 2 OF OUTPUT
C M2	WORD 3 OF OUTPUT (COMMAND WORD)
C
C	LONGLIB META FILE FORMAT
C
C	M0	M1	M2	COMMAND INTERPRETATION
C
C	X	Y	2	PEN DOWN MOVE
C	X	Y	3	PEN UP MOVE
C	X	Y	-2*	PEN DOWN MOVE WITH NEW ORIGIN
C	X	Y	-3*	PEN UP MOVE WITH NEW ORIGIN
C	X	Y	9	PEN ERASE MOVE
C	X	Y	-9*	PEN ERASE WITH NEW ORIGIN
C	X	Y	10	NEW PAGE
C	-	-	11	END OF FILE
C	-	-	999	END OF FILE
C	RESX	RESY	1000	SET RESOLUTION
C	TYPE	SCALE	1001	SET LINE TYPE
C	-	COLOR	1002	SET PEN COLOR
C	WIDTH	-	1003	SET LINE WIDTH
C	XSC	YSC	2000	IMAGE SIZE SCALE FACTOR
C	NX	NY	2001	IMAGE ARRAY SIZES
C	V1	V2	2002	IMAGE DATA
C	N	-	2010	COLOR TABLE ENTRY SIZE
C	R	G	2011	COLOR TABLE DATA R AND G
C	B	C	2012	COLOR TABLE DATA B AND CODES
C	-	-	(ELSE*)	INVALID COMMAND
C
C	* NORMALLY NOT SENT TO FILE
C
C	FIRST COMMAND IN FILE SHOULD SET RESOLUTION
C	NEXT COMMANDS SHOULD SET LINE TYPE, WIDTH AND COLOR
C
	INTEGER*2 MB(128)		! OUTPUT RECORD BUFFER
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/,MB
C
	IF (LU.LE.0) RETURN			! NO PRINT FLAG
	IF (MP.LT.0) GOTO 20			! CHECK FOR FILE CLOSED
	MP=3+MP					! INCREMENT POINTER
	IF (MP.LT.128) GOTO 10			! CHECK FOR FULL BUFFER
	WRITE (LU) MB				! WRITE RECORD
	MP=3
10	MB(MP)=int(M2,2)			! STORE DATA (I4->I4)
	MB(MP-1)=int(M1,2)
	MB(MP-2)=int(M0,2)
	IF (M2.NE.11.AND.M2.NE.999) GOTO 20	! CHECK FOR END OF PLOTS
	WRITE (LU) MB				! WRITE LAST RECORD
	CLOSE (LU)				! CLOSE FILE
	MP=-1					! FLAG END OF PLOTS
20	RETURN
	END
C
C
	SUBROUTINE PPLOTS(IA,X0,Y0,ZOM)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	INITIALIZE PRINTER HISTORY FILE GRAPHICS PACKAGE
C
C IA	LOGICAL UNIT FOR OUTPUT
C	= 0   DEFAULTS TO 3
C	< 0  DOES NOT PRODUCE OUTPUT
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
C
	LU=IA			! FORTRAN FILE NUMBER
	OX=X0			! ORIGIN X
	OY=Y0			! ORIGIN Y
	SF=ZOM			! SCALE FACTOR
	IF (SF.LE.0.0) SF=1.0
	PANG=0.0		! PLOTTING ANGLE ROTATION
	PX=0.0			! LAST POINT PLOTTED
	PY=0.0
	IR1=1000		! "PIXELS" PER INCH RESOLUTION
	IR2=1000
	RE(1)=1./FLOAT(IR1)	! RESOLUTION FOR META FILE
	RE(2)=1./FLOAT(IR2)
	PVP(1)=0.0		! VIEW PORT PARAMETERS LOWER LEFT
	PVP(2)=0.0
	CALL PPLOT(999.,999.,4)	! VIEW PORT UPPER RIGHT CORNER SET
	CALL PPLOT(-999.,-999.,-4)
	IF (LU.EQ.0) LU=3
	MP=0			! PRINT BUFFER COUNTER
	MX=0			! DEFAULT LINE TYPE (SOLID)
	MSC=1			! DEFAULT LINE SCALING (UNIT)
	MW=1			! DEFAULT LINE WIDTH (UNIT)
	MCOL=1			! DEFAULT LINE COLOR
	IF (LU.LT.0) RETURN
	CALL PPLOTP(IR2, IR1,1000)	! INITIALIZE RESOLUTION
	CALL PPLOTP(MX , MSC,1001)	! INITIALIZE LINE TYPE, SCALING
	CALL PPLOTP(MW ,MCOL,1002)	! INITIALIZE LINE COLOR
	CALL PPLOTP(MW ,   0,1003)	! INITIALIZE LINE WIDTH
	RETURN
	END
C
C
	SUBROUTINE METAON(IA)
C
C	TURNS ON/OFF HISTORY FILE (META FILE) OUTPUT
C	META FILE MUST HAVE BEEN PREVIOUSLY INITIALIZED
C
C	IA	(I)	METAFILE OPTION FLAG
C			= -1: TURN OFF META FILE PLOTTING
C			= +1: TURN ON META FILE PLOTTING
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
C
	IF (LU.EQ.0) RETURN	! NOT INITIALIZED
	IF (IA.EQ.-1) THEN	! TURN META FILE OFF
		IF (LU.GT.0) LU=-10000-LU
	ELSE IF (IA.EQ.1) THEN	! TURN META FILE ON
		IF (LU.LT.-10000) LU=-LU-10000
	ENDIF
C
	RETURN
	END
C
C
	SUBROUTINE PPEN(IP)
C
C	SELECT PRINTER PLOTTING LINE TYPE
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C IP	PEN CONTROL WORD (IP<0 RESETS LINE TYPE TO SOLID, 1 DOT WIDE)
C
C	UNITS DIGIT=LINE TYPE
C	  0 = NO CHANGE
C	  1-9 LINE TYPE
C
C	TENS  DIGIT=LINE WIDTH
C	  0 = NO CHANGE
C	  1-7 WIDTH IN DOTS
C
C	HUNDREDS DIGIT=LINE TYPE SCALE FACTOR
C	  0 = NO CHANGE
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
C
	IF (IP.LE.0) THEN
		M=1
		MW1=1
		MSC=1
		GOTO 10
	ENDIF
	MSC1=IP/100
	IF (MSC1.NE.0) MSC=MSC1
	MW1=MOD(IP,100)/10
	M=MOD(IP,10)
	IF (M.EQ.0) M=MX+1
10	MX=M-1
C
	IF (LU.GT.0) THEN
C
C	CHANGE LINE TYPE AND SCALE
C
		CALL PPLOTP(MX,MSC,1001)
C
C	CHANGE PEN WIDTH
C
		IF (MW1.NE.0) THEN
			MW=MW1
			CALL PPLOTP(MW,0,1003)
		ENDIF
	ENDIF
	RETURN
	END
C
C
	SUBROUTINE RMPEN(IP)
C
C	MODIFY RAMTEK PLOTTING LINE TYPE
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C IP	PEN CONTROL WORD
C		NOTE: IP<0 RESET TO SOLID LINE, WIDTH 1
C
C	UNITS DIGIT=LINE TYPE
C	  0 = NO CHANGE
C	  1-9 LINE TYPE
C
C	TENS  DIGIT=LINE WIDTH
C	  0 = NO CHANGE
C	  1-7 LINE WIDTH
C
C	HUNDREDS DIGIT=LINE TYPE SCALE FACTOR
C	  0 = NO CHANGE
C	  1-7 BIT PATTERN SCALE FACTOR
C
	COMMON/RMTEK/ICHAN,IMR(128),RRE(2),ROX,ROY,RSF,NIMR,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
C
	IF (IP.LE.0) THEN
		M=1
		IPW=1
		IPSC=0
		GOTO 10
	ENDIF
	IPSC1=IP/100
	IF (IPSC1.NE.0) IPSC=IPSC1-1
	IPW1=MOD(IP,100)/10
	IF (IPW1.GT.7) IPW1=7
	IF (IPW1.NE.0) IPW=IPW1
	M=MOD(IP,10)
	IF (M.EQ.0) M=MM+1
10	MM=M-1
	CALL RMTEXTURE(ICHAN,MM,IPW,IPSC,IERR)
	RETURN
	END
C
C
	SUBROUTINE VPEN(IP)
C
C	CHANGE TERMINAL PLOTTING LINE TYPE
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C IP	PEN CONTROL WORD
C		NOTE: IP<0 IS RESET TO SOLID LINE UNIT WIDTH
C
C	UNITS DIGIT=LINE TYPE
C	  0 = NO CHANGE
C	  1-9 LINE TYPE
C
C	TENS  DIGIT=LINE WIDTH
C	  0 = NO CHANGE
C	  1-7 LINE WIDTH
C
C	HUNDREDS DIGIT=LINE TYPE SCALE FACTOR (NOT IMPLEMENTED)
C
	MV=0
	MVW=1
	IF (IP.LE.0) GOTO 10
	MVW1=MOD(IP,100)/10
	IF (MVW1.NE.0) MVW=MVW1
	MV1=MOD(IP,10)
	IF (MV1.EQ.0) MV1=MV+1
	MV=MV1-1
10	CONTINUE
C
C	CALL TERMINAL DEPENDENT ROUTINE TO CHANGE LINE TYPE
C
	CALL NEWVPEN(MV,MVW)
	RETURN
	END
C
C
	SUBROUTINE NEWPAGE
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C	THIS ROUTINE CAUSES A RESETING OF THE PRINTER PAGE WITHOUT
C	AFFECTING SCREEN DEVICES
C
	CALL PPLOT(0.,0.,10)		! EJECT PRINTER PAGE
	RETURN
	END
C
C
	SUBROUTINE FACTOR(SC)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	CHANGE SCALE FACTORS FOR ALL PLOT PACKAGES
C
C	SC  SCALE FACTOR
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/,/RMTEK/,/VT100/
	COMMON/RMTEK/ICHAN,IMR(128),RRE(2),ROX,ROY,RSF,NIMR,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
C
	IF (LU.GE.0) CALL PFACTOR(SC)
	IF (ICHAN.GE.0) CALL RFACTOR(SC)
	IF (IVT100.GE.0) CALL VFACTOR(SC)
	RETURN
	END
C
C
	SUBROUTINE NEWPEN(IP)
C
C	CHANGE PLOTTING LINE TYPE ON ALL DEVICES
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C IP	PEN TYPE CONTROL WORD 
C		NOTE: IP<0 RESETS PEN WIDTH TO 1 AND LINE TYPE TO SOLID
C
C	NOT ALL GRAPHICS DEVICES SUPPORT ALL HARWARE LINE TYPES.  IF THEY DO,
C	THE LINE TYPES SHOULD RESEMBLE THESE:
C
C	UNITS DIGIT = LINE TYPE 0-9
C	  0 = NO CHANGE
C	  1-9 LINE TYPE
C		TYPE	PATTERN
C		 1	SOLID
C		 2	DOTTED
C		 3	LONG-DOT-LONG
C		 4	MEDDASH-MEDDASH
C		 5	LONGDASH-LONGDASH
C		 6	LONG-DOT-DOT-LONG
C		 7	LONG-SHORT-LONG
C		 8	SHORT-SHORT
C		 9	LONG-DOT-DOT-DOT-LONG
C
C	TENS  DIGIT = LINE WIDTH IN PIXELS OR DOTS
C	  0 = NO CHANGE
C	  1-7 LINE WIDTH
C
C	HUNDREDS DIGIT = LINE TYPE SCALE FACTOR
C	  0 = NO CHANGE
C	  1-9 LINE TYPE SCALE FACTOR
C
C	FIRST PICK UP PEN AT CURRENT LOCATION, THEN CHANGE LINE TYPE
C
	CALL PLOT(0.,0.,5)
C
	CALL RMPEN(IP)
	CALL PPEN(IP)
	CALL VPEN(IP)
	RETURN
	END
C
C
	SUBROUTINE PLOTND
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	TERMINATES PLOTS 
C
	CALL PLOT(0.,0.,999)
	RETURN
	END
C
C
	SUBROUTINE FIXRM0(ORX,ORY,ZOM,ANG,RX,RY,NT,NS,ICOLOR,NCHAN)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	SET PLOT COMMON DATA TO ABSOLUTE KNOWN VALUES
C	NO ERROR CHECKING PROVIDED
C
	COMMON/RMTEK/ICHAN,IMR(128),RRE(2),ROX,ROY,RSF,NIMR,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
C
	ROX=ORX				! X ORIGIN
	ROY=ORY				! Y ORIGIN
	RSF=ZOM				! ZOOM SCALE FACTOR
	RANG=ANG			! PLOTTING ANGLE
C	RRE(1)=RX*RSF			! X DIRECTION RESOLUTION
C	RRE(2)=RY*RSF			! Y DIRECTION RESOLUTION
	MM=NT				! LINE TYPE
	IPW=NS				! PIXEL SCALING OF LINE TYPE
	ICHAN=NCHAN			! CHANNEL NUMBER IF NCHAN > 0
	ICOL=ICOLOR			! CURRENT COLOR TABLE VALUE
	CALL RMTEXTURE(ICHAN,MM,IPW,IPSC,IERR)
	RETURN
	END
C
	SUBROUTINE FIXVT0(ORX,ORY,ZOM,ANG,RX,RY,NVT,ISEL,NT,NW,NCOL)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	SET PLOT COMMON DATA TO ABSOLUTE KNOWN VALUES
C	NO ERROR CHECKING PROVIDED
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	SAVE /VT100/
C
	VOX=ORX				! X ORIGIN
	VOY=ORY				! Y ORIGIN
	VSF=ZOM				! ZOOM SCALE FACTOR
	VANG=ANG			! PLOTTING ANGLE
C	VRE(1)=RX*VSF			! X DIRECTION RESOLUTION
C	VRE(2)=RY*VSF			! Y DIRECTION RESOLUTION
	IVT100=NVT			! NVT > 0 MEANS VT ENABLED
	ITERM=ISEL			! INTERNAL TERMINAL CODE
	MV=NT				! LINE TYPE
	MVW=NW				! LINE WIDTH
	IVCOL=NCOL			! LINE COLOR
	CALL NEWVPEN(MV,MVW)		! CHANGE TERMINAL LINE TYPE
	RETURN
	END
C
C
	SUBROUTINE FIXPR0(ORX,ORY,AX,AY,ZOM,ANG,RX,RY,NVT,MXX,MWW,MCOLL)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	SET PRINTER COMMON DATA TO ABSOLUTE KNOWN VALUES
C	NO ERROR CHECKING PROVIDED
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/
C
	OX=ORX				! X ORIGIN
	OY=ORY				! Y ORIGIN
	PX=AX				! LAST SCALED, SHIFTED X
	PY=AY				! LAST SCALED, SHIFTED Y
	SF=ZOM				! ZOOM SCALE FACTOR
	PANG=ANG			! PLOTTING ANGLE
C	RE(1)=RX*SF			! X DIRECTION RESOLUTION
C	RE(2)=RY*SF			! Y DIRECTION RESOLUTION
	LU=NVT				! NVT > 0 MEANS PR ENABLED
	MX=MXX				! LINE TYPE
	MW=MWW				! LINE WIDTH
	MCOL=MCOLL			! LINE COLOR
C WRITE DATA TO FILE
	IF (LU.GT.0) THEN
		CALL PPLOTP(MX,MSC,1001)	! LINE TYPE, SCALE
		CALL PPLOTP(MW,MCOL,1002)	! LINE COLOR
		CALL PPLOTP(MW,0,1003)		! LINE WIDTH
	ENDIF
	RETURN
	END
C
C
	SUBROUTINE WHERE(X,Y,Z)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C	RETURN LAST VALUES IN CALL TO PLOT.
C
C	X,Y	(R): 	LAST POSITION
C	Z	(R):	SCALE FACTOR--PRIORITIZED TERMINAL,RAMTEK,PRINTER
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC,
     $		PANG,PVP(4)
	SAVE /PXPCOM/,/RMTEK/,/VT100/,/LSTPLT/
	COMMON/RMTEK/ICHAN,IMR(128),RRE(2),ROX,ROY,RSF,NIMR,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
C
	COMMON/LSTPLT/XLAST,YLAST,I0LAST
C
	X=XLAST
	Y=YLAST
	Z=SF
	IF (ICHAN.GT.0) Z=RSF
	IF (IVT100.GT.0) Z=VSF
	RETURN
	END
C
C
	SUBROUTINE ABSPLT(X,Y,A,Z)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C	SET PLOTTING ORIGIN, ANGLE, AND SCALE FACTOR TO ABSOLUTE UNITS
C	NO ERROR CHECKING DONE
C
C	X,Y	NEW ORIGIN
C	A	NEW ANGLE
C	Z	NEW SCALE FACTOR
C
	CALL WHEREVT(ORX,ORY,ZOM,ANG,RX,RY,NVT,ISEL,NT,NW,NCOL)
	CALL FIXVT0(X,Y,Z,A,RX,RY,NVT,ISEL,NT,NW,NCOL)
	CALL WHEREPR(ORX,ORY,AX,AY,ZOM,ANG,RX,RY,NLU,MXX,MWW,MCOLL)
	CALL FIXPR0(X,Y,AX,AY,Z,A,RX,RY,NLU,MXX,MWW,MCOLL)
	CALL WHERERM(ORX,ORY,ZOM,ANG,RX,RY,NT,NS,ICOLOR,NCHAN)
	CALL FIXRM0(X,Y,Z,A,RX,RY,NT,NS,ICOLOR,NCHAN)
	RETURN
	END
C
C
	SUBROUTINE SAVPL
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C	CENTRAL ROUTINE TO SAVE THE CURRENT PLOTTING STATE
C
	CALL WHERE(X,Y,Z)	! GET LAST PLOT COMMAND
	CALL PLOT(X,Y,3)	! DO PENUP
	CALL PSAVPL
	CALL RSAVPL
	CALL VSAVPL
	RETURN
	END
C
	SUBROUTINE RESPL
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C	CENTRAL ROUTINE TO SAVE THE CURRENT PLOTTING STATE
C
	CALL WHERE(X,Y,Z)	! GET LAST PLOT COMMAND
	CALL PLOT(X,Y,3)	! DO PENUP
	CALL PRESPL
	CALL RRESPL
	CALL VRESPL
	RETURN
	END
C
C
	SUBROUTINE PSAVPL
C
C	ROUTINE TO SAVE THE CURRENT PRINTER HISTORY FILE PLOTTING STATE
C	SAVES UP TO SIX LEVELS OF SOFTWARE STACK
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
	DIMENSION SOX(6),SOY(6),SSF(6),SANG(6),SVP(4,6)
	INTEGER ISCOL(6),ISMW(6),ISMX(6),IMSC(6)
C
	COMMON/PXPCOM/LU,MP,RE(2),OX,OY,SF,PX,PY,MX,MW,MCOL,MSC, 
     $		PANG,PVP(4)
	SAVE
	DATA NS/0/
C
	IF (LU.LE.0) RETURN
	IF (NS.GT.5) RETURN	! STACK OVERFLOW
	NS=NS+1
	SOX(NS)=OX
	SOY(NS)=OY
	SSF(NS)=SF
	SANG(NS)=PANG
	DO 1 I=1,4
		SVP(I,NS)=PVP(I)
1	CONTINUE
	ISMX(NS)=MX
	IMSC(NS)=MSC
	ISMW(NS)=MW
	ISCOL(NS)=MCOL
	RETURN
C
	ENTRY PRESPL
C
C	RESTORES SAVED PRINTER HISTORY PLOTTING STATE
C
	IF (NS.LT.1) RETURN	! EMPTY STACK
	OX=SOX(NS)
	OY=SOY(NS)
	SF=SSF(NS)
	PANG=SANG(NS)
	DO 2 I=1,4
		PVP(I)=SVP(I,NS)
2	CONTINUE
	MX=ISMX(NS)
	MSC=IMSC(NS)
	MW=ISMW(NS)
	MCOL=ISCOL(NS)
	CALL PPLOTP(MX,MSC,1001)	! LINE TYPE, SCALE
	CALL PPLOTP(MW,MCOL,1002)	! LINE COLOR
	CALL PPLOTP(MW,0,1003)		! LINE WIDTH
	NS=NS-1
	RETURN
	END
C
C
	SUBROUTINE RSAVPL
C
C	ROUTINE TO SAVE THE CURRENT RAMTEK PLOTTING STATE
C	SAVES UP TO SIX LEVELS OF SOFTWARE STACK
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
	DIMENSION SOX(6),SOY(6),SSF(6),SANG(6),SVP(4,6)
	INTEGER ISCOL(6),ISPW(6),ISMM(6),ISPSC(6)
C
	COMMON/RMTEK/ICHAN,IMR(128),RRE(2),ROX,ROY,RSF,NIMR,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE
	DATA NS/0/
C
	IF (NS.GT.5) RETURN	! STACK OVERFLOW
	NS=NS+1
	SOX(NS)=ROX
	SOY(NS)=ROY
	SSF(NS)=RSF
	SANG(NS)=RANG
	DO 1 I=1,4
		SVP(I,NS)=RVP(I)
1	CONTINUE
	ISCOL(NS)=ICOL
	ISMM(NS)=MM
	ISPW(NS)=IPW
	ISPSC(NS)=IPSC
	RETURN
C
	ENTRY RRESPL
C
C	RESTORES SAVED RAMTEK PLOTTING STATE
C
	IF (NS.LT.1) RETURN	! EMPTY STACK
	ROX=SOX(NS)
	ROY=SOY(NS)
	RSF=SSF(NS)
	RANG=SANG(NS)
	DO 2 I=1,4
		RVP(I)=SVP(I,NS)
2	CONTINUE
	ICOL=ISCOL(NS)
	MM=ISMM(NS)
	IPW=ISPW(NS)
	IPSC=ISPSC(NS)
	CALL RMTEXTURE(ICHAN,MM,IPW,IPSC,IERR)
	NS=NS-1
	RETURN
	END
C
C
	SUBROUTINE VSAVPL
C
C	ROUTINE TO SAVE THE CURRENT TERMINAL PLOTTING STATE
C	SAVES UP TO SIX LEVELS OF SOFTWARE STACK
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
	DIMENSION SOX(6),SOY(6),SSF(6),SANG(6),SVP(4,6)
	INTEGER ISMV(6),ISMW(6),ISCOL(6)
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	SAVE
	DATA NS/0/
C
	IF (NS.GT.5) RETURN	! STACK OVERFLOW
	NS=NS+1
	SOX(NS)=VOX
	SOY(NS)=VOY
	SSF(NS)=VSF
	SANG(NS)=VANG
	DO 1 I=1,4
		SVP(I,NS)=VVP(I)
1	CONTINUE
	ISMV(NS)=MV
	ISMW(NS)=MVW
	ISCOL(NS)=IVCOL
	RETURN
C
	ENTRY VRESPL
C
C	RESTORES SAVED TERMINAL PLOTTING STATE
C
	IF (NS.LT.1) RETURN	! EMPTY STACK
	VOX=SOX(NS)
	VOY=SOY(NS)
	VSF=SSF(NS)
	VANG=SANG(NS)
	DO 2 I=1,4
		VVP(I)=SVP(I,NS)
2	CONTINUE
	MV=ISMV(NS)
	MVW=ISMW(NS)
	IVCOL=ISCOL(NS)
	CALL NEWVPEN(MV,MVW)
	CALL PLOTVT(FLOAT(IVCOL),0.,0)
	NS=NS-1
	RETURN
	END
C
C
	SUBROUTINE TERSCL(ID,IT,X,Y,IX,IY)
C
C	AUTHOR:   DGL AUG, 1990
C
C	COMPUTES THE TRANSFORMATION TO/FROM TERMINAL COORDINATES
C
C	PARAMETERS:
C	  ID :	TRANSFORMATION DIRECTION FLAG (INPUT)
C		 > 0 FORWARD (STANDARD TO TERMINAL PIXEL COORDINATES)
C		ELSE REVERSE (FROM TERMINAL PIXEL COORINATES TO STANDARD)
C	  IT :  TERMINAL FLAG (RETURNED)
C		 -1 : TERMINAL PACKAGE NOT ENABLED
C		  0 : NON-TEKTRONICS 42XX COMPATIBLE TERMINAL
C		  1 : TEKTRONICS 42XX COMPATIBLE TERMINAL
C	  X,Y:  STANDARD COORDINATES
C		  INPUT IF ID>0, OUTPUT OTHERWISE
C	  IX,IY:TERMINAL PIXEL COORDINATES
C		  OUTPUT IF ID>0, INPUT OTHERWISE
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	SAVE /VT100/
C
	IT=-1			! ERROR RETURN
	IF (IVT100.LE.0) RETURN
C
C	RETURN TERMINAL TYPE
C
	IT=0			! NON-TEXTRONICS 42XX COMPATIBLE TERMINAL
	IF (ITERM.EQ.6)	IT=1	! Tektronics 4107/4109
C
C	COMPUTE TRANSFORMATION, ROTATION, AND SCALING
C
	TANG=VANG*.017453294
	IF (ID.GT.0) THEN	! FORWARD TRANSFORMATION
		AV1=X*COS(TANG)-Y*SIN(TANG)
		AV2=X*SIN(TANG)+Y*COS(TANG)
		IX=int((VSF*AV1+VOX)/VRE(1))
		IY=int((VSF*AV2+VOY)/VRE(2))
		IF (IYREV.EQ.1) IY=IYLIM-IY
	ELSE			! INVERSE TRANSFORMATION
		IF (IYREV.EQ.1) IY=IYLIM-IY
		AV1=(IX*VRE(1)-VOX)/VSF
		AV2=(IY*VRE(2)-VOY)/VSF
		X=AV1*COS(TANG)+AV2*SIN(TANG)
		Y=-AV1*SIN(TANG)+AV2*COS(TANG)
	ENDIF
C
	RETURN
	END
C
C *************************************************************************
C
C THE FOLLOWING ROUTINES ARE BASED ON THE DEC VAX ASYNCHRONOUS CONTROL-C
C INTERRUPT HANDLING PROTOCALL.  "ENAST" IS A MACHINE DEPENDENT ROUTINE
C WHICH ENABLES/DISABLES THE CONTROL-C INTERRUPT.  IT IS CALLED BY "ENABLEAST"
C TO ENABLE THE INTERRUPT AND BY "ASTEXIT" (WHICH IS CALLED WHEN INTERRUPT
C OCCURS).  IN THIS FILE, WE REPLACE THESE ROUTINES WITH DUMMY CALLS SO
C THAT THE CONTROL-C ROUTINES ARE NOT USED.  A SEPARATE FILE CONTAINS
C THE WORKING CODE.  THE OTHER FILE CAN BE SUBSTITUTED TO ALLOW CONTROL-C
C INTERRUPTS.  WHEN AN INTERRUPT OCCURS, WE SET A FLAG IN THE "ASTC"
C COMMON BLOCK AND CONTINUE IF THE TERMINAL PACKAGE IN LONGLIB IS IN USE
C OTHERWISE WE DIRECTLY CALL THE INTERRUPT HANDLER "ASTINTER".  IF THE
C TERMINAL PACKAGE IS IN USE, EACH TIME "PLOT" IS CALLED WE CHECK THE STATUS
C OF THE FLAG.  IF THE FLAG IS SET WE CALL THE INTERRUPT HANDLER "ASTINTER"
C WHICH CAN EXIT THE PROGRAM, RESET TERMINAL CONDITION, ETC.  IN THIS WAY
C WE CAN USE THE CONTROL-C STUFF WITH OR WITHOUT LONGLIB BE USED AT ALL.
C IF YOU WISH TO USE THE CONTROL-C STUFF WITHOUT THE REST OF LONGLIB,
C CALL "ENABLEAST" FROM YOUR CODE.  THE LONGLIB ROUTINE "FRAME" CALLS
C "ENABLAST" WHEN THE LONGLIB PACKAGE IS USED.
C
C YOU CAN ELIMINATE THESE ROUTINES IF DESIRED.  IF THIS IS DONE BE SURE
C TO COMMENT OUT THE CONTROL-C LINES IN THE ROUTINE 'PLOT' AND 'FRAME'.
C
C **********************************************************************
C
	SUBROUTINE ENABLEAST
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	ENABLE CONTROL-C INTERRUPT
C
C	DUMMY ROUTINE
C
	COMMON/ASTC/IASTFL,IASTPL
	SAVE /ASTC/
C
	IASTFL=0			! CONTROL-C INTERRUPT FLAG
	IASTPL=0			! CURRENTLY PLOTTING FLAG
	RETURN
	END
C
C
	SUBROUTINE ENAST(IOPT)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C	CONTROL-C INTERRUPT QIO SET UP
C
C	DUMMY ROUTINE
C
	RETURN
	END
C
C
	SUBROUTINE ASTEXIT(IOPT)
C
C	FORTRAN-77 VERSION:   DGL JULY, 1987
C
C	ROUTINE CALLED IN THE EVENT OF A CONTROL-C FROM THE TERMINAL.
C	A FLAG (IASTFL) IS SET AND IF WE ARE PLOTTING TO THE TERMINAL
C	THE ROUTINE RETURNS.  IF NOT PLOTTING TO THE TERMINAL, THE
C	CONTROL-C HANDLER IS CALLED IMMEDIATELY
C
	COMMON/ASTC/IASTFL,IASTPL
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	SAVE /VT100/,/ASTC/
C
	CALL ENAST(IOPT)		! RESET CONTORL-C QIO
	IF (IASTFL.LT.0) RETURN		! NO CONTROL-C INTERRUPTS DURING
C					!  A CONTROL-C INTERRUPT
	IF (IVT100.LT.0) THEN		! TERMINAL PACKAGE NOT IN CURRENT USE
		IASTFL=0		! IMMEDIATELY CALL INTERRUPT HANDLER
		CALL ASTINTER(IASTFL)
	ELSE				! TERMINAL PACKAGE IN USE
		IF (IASTPL.EQ.1) THEN	! CURRENTLY PLOTTING, INTERRUPT LATER
			IASTFL=1
		ELSE			! NOT PLOTTING, INTERRUPT NOW
			IASTFL=0
			CALL ASTINTER(IASTFL)
		ENDIF
	ENDIF
	RETURN
	END
C
C
	SUBROUTINE ASTINTER(IV)
C
C	CONTROL-C INTERUPT HANDLING CODE
C	USES THE CURRENT MODE OF THE GRAPHICS TERMINAL TO INSURE THAT
C	TERMINAL IS IN TERMINAL MODE AND IS RETURNED TO GRAPHICS MODE
C	IF IN THAT MODE.  IF LONGLIB IS NOT ENABLED, THE OPTION TO CONTINUE
C	OR ABORT PROGRAM IS GIVEN.
C
	CHARACTER*1 IANS
C
	COMMON/ASTC/IASTFL,IASTPL
C
	COMMON/VT100/IVT100,IMV(32),VRE(2),VOX,VOY,VSF,NIMV,VANG,ITERM,
     $		VVP(4),MV,MVW,IVCOL,IXLIM,IYLIM,IYREV,VLIM(2),IMODE
	SAVE /VT100/,/ASTC/
C
	IASTFL=-1		! ENTERING HANDLER SO FLAG NO INTERRUPT
	ISMODE=IMODE		! SAVE CURRENT GRAPHICS/TERMINAL MODE
	CALL CTERM(1)		! PUT TERMINAL IN TERMINAL MODE
	WRITE (*,1)
1	FORMAT(/' *** CONTROL-C INTERRUPT ***')
505	WRITE (*,2)
2	FORMAT(' <RET> TO CONTINUE <^Z> TO ABORT: ',$)
	READ (*,3,END=99) IANS
	IF (IANS.EQ.'?') THEN
		WRITE(*,84)
84		FORMAT(/'X,Z: Abort program'/
     $		' C : Clear screen '/
     $		' Q : Quit (disable screen plotting)'/
     $		' S : Skip screen plotting until next "clear screen"'/,
     $		' R : Reset skip'/,
     $		' U : Unquit'/,
     $		' T : Set screen to terminal mode'/,
     $		' G : Set screen to graphics mode')
		GOTO 505
	ENDIF
	IF (IANS.EQ.'Z'.OR.IANS.EQ.'z') GOTO 99		! TERMINATE PROGRAM
	IF (IANS.EQ.'X'.OR.IANS.EQ.'x') THEN		! TERMINATE/CLEAR
		CALL CTERM(2)
		GOTO 99
	ENDIF
	IF (IANS.EQ.'C'.OR.IANS.EQ.'c') CALL CTERM(-2)	! CLEAR SCREEN
	IF (IANS.EQ.'Q'.OR.IANS.EQ.'q') IVT100=-98  ! TURN OFF SCREEN PLOTTING
	IF (IANS.EQ.'S'.OR.IANS.EQ.'s') IVT100=-99	! SKIP PLOTTING
	IF (IANS.EQ.'R'.OR.IANS.EQ.'r'.AND.IVT100.EQ.-99) THEN ! RESET SKIP
		IVT100=1
		ISMODE=1
	ENDIF
	IF (IANS.EQ.'U'.OR.IANS.EQ.'u'.AND.IVT100.EQ.-98) THEN ! UNQUIT
		IVT100=1
		ISMODE=1
	ENDIF
 	IF (IANS.EQ.'T'.OR.IANS.EQ.'t') ISMODE=0	! TERMINAL MODE
	IF (IANS.EQ.'G'.OR.IANS.EQ.'g') ISMODE=1	! GRAPHICS MODE
3	FORMAT(A1)
	IF (ISMODE.EQ.1) CALL CTERM(-1)		! RESTORE TERMINAL GRAPHICS MODE
	IASTFL=0				! EXIT HANDLER
	RETURN
99	CALL EXIT(0)				! TERMINATE PROGRAM
	END
C
C *************************************************************************
C
C  GRAPHICS TERMINAL AUXILARY ROUTINES
C
C *************************************************************************
C
	SUBROUTINE TEKMAP(IARRAY,NA,MA,N,M,IXS,IYS,BX,BY)
C
C	PROGRAM TO MAKE AN IMAGE MAP ON A TEKTRONIX 42XX TERMINAL
C
C	AUTHOR: DG LONG, JPL
C	DATE: 9 AUG 1990
C
C	INPUTS:
C	  IARRAY  : COLOR/PATTERN CODE
C		       < -15   : LEAVE BLANK
C		    -15 TO   0 : SPECIFIES SOLID COLOR
C		      1 TO  16 : SPECIFIES PREDEFINED PATTERN
C		     50 TO 174 : SPECIFIES PREDEFINED DITHER PATTERN
C	  NA,MA	  : DIMENSIONS OF IARRAY
C	  N,M	  : PLOT N BY M PORTION OF IARRAY
C	  IXS,IYS : POSITION OF LOWER LEFT CORNER OF MAP (IN TEK UNITS
C		     WITH RANGE: 0-4096)
C	  BX,BY : BOX SIZE (IN TEK UNITS WITH RANGE:  0.0 < BX,BY < 4095.0)
C
C	CALLS:
C	  TEKBOX
C
	INTEGER IARRAY(NA,MA)
C
C	MAKE MAP IN COLUMN ORDER TO MINIMIZE BOXES OUTPUT IF POSSIBLE
C
	DO 30 IY=1,M
	  IX=1
	  IN=IARRAY(IX,IY)
	  JNT=-99
18	  IF (IX.LE.N) THEN
	    DO 20 JX=IX+1,N+1
	      IF (JX.LE.N) JNT=IARRAY(JX,IY)
	      IF (JNT.NE.IN.OR.JX.GT.N) THEN
		IF (IN.GT.-15.AND.IN.LT.175) 
     $			CALL TEKBOX(NINT(IXS+BX*(IX-1)),
     $			  NINT(IYS+BY*(IY-1)),NINT(BX*(JX-IX)),
     $			  NINT(BY),IN)
	        IN=JNT
	        IX=JX
	        GOTO 18
	      ENDIF
20	    CONTINUE
	  ENDIF
30	CONTINUE
C
	RETURN
	END 
C
C
	SUBROUTINE TEKBOX(MX,MY,NX,NY,IFILL)
C
C	DRAW A FILLED RECTANGULAR BOX ON A TEKTRONICS 42XX SERIES USING
C	PANEL FILL WITH LOWER LEFT COORDINATES (MX,MY)
C	AND SIDES (NX,NY) AND FILL PATTERN IFILL.  TERMINAL SHOULD BE
C	IN TEKTRONICS MODE.
C
C	AUTHOR: DG LONG
C	DATE: 8 AUG 1990
C
C	INPUTS:
C	MX,MY,NX,NY	(I): TEKCODED (0-4095) POINTS
C	IFILL		(I): FILL PATTERN/COLOR
C				-15 TO   0: SOLID COLOR
C				  1 TO  16: PREDEFINED PATTERN
C				 50 TO 174: PREDEFINED DITHER PATTERN
C
C	CALLS:	INT1X,TEKCODE
C
	INTEGER MPLOT(2),JR(3),B(39)
	DATA IFILLL/-999/		! LAST FILL VALUE
	SAVE IFILLL
C
C	SELECT FILL PATTERN
C
	IF (IFILL.NE.IFILLL) THEN
	  B(1)=27			! ESC
	  B(2)=77			! SELECT FILE PATTERN (MP)
	  B(3)=80
	  CALL INT1X(IFILL,NB,JR)
	  DO J=1,NB
	   B(3+J)=JR(J)
	  END DO
	  ICNT=4+NB
	  IFILLL=IFILL
	ELSE
	  ICNT=1
	ENDIF
C
C	BEGIN PANEL
C
	B(ICNT)=27			! ESC
	B(ICNT+1)=76			! BEGIN PANEL BOUNDARY (LP)
	B(ICNT+2)=80
	ICNT=ICNT+3
	MPLOT(1)=MX
	MPLOT(2)=MY
	CALL TEKCODE(1,MPLOT,B,ICNT)
C
C	DEFINE PANEL BOUNDARY
C
	B(ICNT)=27
	B(ICNT+1)=76			! DEFINE PANEL BOUNDARY (LG)
	B(ICNT+2)=71
	ICNT=ICNT+3
	MPLOT(1)=MX+NX
	CALL TEKCODE(1,MPLOT,B,ICNT)
	B(ICNT)=27
	B(ICNT+1)=76			! DEFINE PANEL BOUNDARY (LG)
	B(ICNT+2)=71
	ICNT=ICNT+3
	MPLOT(2)=MY+NY
	CALL TEKCODE(1,MPLOT,B,ICNT)
	B(ICNT)=27
	B(ICNT+1)=76			! DEFINE PANEL BOUNDARY (LG)
	B(ICNT+2)=71
	ICNT=ICNT+3
	MPLOT(1)=MX
	CALL TEKCODE(1,MPLOT,B,ICNT)
C
C	END PANEL
C
	B(ICNT)=27			! ESC
	B(ICNT+1)=76			! END PANEL (LE)
	B(ICNT+2)=69
	ICNT=ICNT+2
C
C	OUTPUT LINE OF DATA TO TERMINAL
C
	WRITE (*,1) (B(I),I=1,ICNT)
1	FORMAT(' ',39A1)
C
	RETURN
	END
C
C
	SUBROUTINE INT1X(INTARG,NB,JR)
C
C	TEKTRONICS ENCODE AN INTEGER PARAMETER INTO ASCII VALUES WITH
C	SHORTEST POSSIBLE STRING LENGTH
C
C	INPUT:	INTARG	: INTEGER NUMBER TO BE ENCODED
C	OUTPUT: NB	: ELEMENTS 1 THROUGH NB CONTAIN RESULT
C			   0 < NB < 4
C		JR	: INTEGER ARRAY CONTAINING ASCII-ENCODED NUMBER
C			  WITH JR(1) CONTAINING MOST SIGNIFICANT VALUE
C
C	AUTHOR: DG LONG
C	DATE: 8 AUG 1990
C
	DIMENSION JR(3)
	JINT=IABS(INTARG)
	IF (JINT/1024.GT.0) THEN
		JR(1)=JINT/1024
		JR(2)=MOD(JINT/16,64)
		JR(3)=MOD(JINT,16)+32
		IF (INTARG.GE.0) JR(3)=JR(3)+16
		NB=3
	ELSE IF (MOD(JINT/16,64).GT.0) THEN
		JR(1)=MOD(JINT/16,64)
		JR(2)=MOD(JINT,16)+32
		IF (INTARG.GE.0) JR(2)=JR(2)+16
		NB=2
	ELSE
		JR(1)=MOD(JINT,16)+32
		IF (INTARG.GE.0) JR(1)=JR(1)+16
		NB=1
	ENDIF
	RETURN
	END
C
C
	SUBROUTINE TEKCODE(N,M,B,IB)
C
C	ENCODES A TEKTRONICS POINT LOCATION WITH MINIMUM SIZE
C
C N	NUMBER OF POINTS
C M	ARRAY OF POINTS TO BE OUTPUT (RANGE: 0-4095)
C		M(1) = X1
C		M(2) = Y1
C		M(3) = X2
C		M(4) = Y2,... ETC
C B	ARRAY OF INTEGERS TO STORE ASCII VALUES
C IB	POINTER TO NEXT POSITION IN B
C
	INTEGER M(*),B(*)
	INTEGER HIX,LOX,HIY,LOY,EX,LHIX,LHIY,LLOY,LEX,MX,MY
	SAVE LHIX,LHIY,LLOY,LEX
C
	IF (N.LT.1) RETURN
C
C	COMPUTE HI-RES TEKTRONICS COORDINATES BUT PASS ONLY APPROPRIATE DATA
C
	N2=2*N
	DO 100 I=1,N2,2
C
	  MX=M(I)
	  MY=M(I+1)
C
C	CLIP TO SCREEN COORDINATES
C
	  MX=MAX(MIN(MX,4095),0)
	  MY=MAX(MIN(MY,4095),0)
C
C	COMPUTE HI-RES TEKTRONICS COORDINATES
C
	  HIX=32+MX/128			! HI-X
	  LOX=64+MOD(MX/4,32)		! LO-X
	  HIY=32+MY/128			! HI-Y
	  LOY=96+MOD(MY/4,32)		! LO-Y
	  EX=96+MOD(MY,4)*4+MOD(MX,4)	! EXTRA
C
C	USE TEXTRONICS CODING STANDARD TO MINIMIZE BYTES SET TO TERMINAL
C
	  IF (I.GT.1) THEN
	    IF (LHIY.NE.HIY) THEN
		B(IB)=HIY
		IB=IB+1
	    ENDIF
	    IF (LEX.NE.EX) THEN
	      B(IB)=EX
	      IB=IB+1
	      IF (LHIX.NE.HIX) THEN
		B(IB)=HIX
		IB=IB+1
	      ENDIF
	    ELSE
	      IF (LOY.NE.LLOY) THEN
		B(IB)=LOY
		IB=IB+1
	  	IF (LHIX.NE.HIX) THEN
		  B(IB)=HIX
		  IB=IB+1
		ENDIF
	      ELSE
		IF (LHIX.NE.HIX) THEN
		  B(IB)=LOY
		  B(IB+1)=HIX
		  IB=IB+2
	        ENDIF
	      ENDIF
	    ENDIF
	    B(IB)=LOX
	    IB=IB+1
	  ELSE
	    B(IB)=HIY
	    B(IB+1)=EX
	    B(IB+2)=LOY
	    B(IB+3)=HIX
	    B(IB+4)=LOX
	    IB=IB+5
	  ENDIF
	  LHIX=HIX
	  LHIY=HIY
	  LLOY=LOY
	  LEX=EX
100	CONTINUE
	RETURN
	END
C
C ************************************************************************
C
C	AUXILARY ROUTINES FOR USE WITH THE RAMTEK PACKAGE OF LONGLIB
C	BOTH RAMTEK AND RAMTEK EMULATION FILE ROUTINES ARE SUPPORTED BY
C	THESE ROUTINES
C
C ************************************************************************
C
	SUBROUTINE RMPIX(X,Y,IX0,IY0)
C
C	RETURNS RAMTEX PIXEL (IX0,IY0) CORRESPONDING TO LONGLIB POINT (X,Y)
C	(NO CLIPPING)
C
	COMMON/RMTEK/ICHAN,IRM(128),RRE(2),ROX,ROY,RSF,NIRM,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
	IF (ICHAN.LT.0) RETURN
C
C	TRANSFORM INPUT POINT
C
	COSA=COS(RANG*0.0174532)
	SINA=SIN(RANG*0.0174532)
	IX0=int(((COSA*X-SINA*Y)*RSF+ROX)/RRE(1))
	IY0=IRYLIM-IFIX(((SINA*X+COSA*Y)*RSF+ROY)/RRE(2)+0.499)
C
C	CODE TO INCLUDE CLIPPING
C
C	IF (IX0.LT.0) IX0=0
C	IF (IX0.GT.IRXLIM) IX0=IRXLIM
C	IF (IY0.LT.0) IY0=0
C	IF (IY0.GT.IRYLIM) IY0=IRYLIM
C
	RETURN
	END
C
C
	SUBROUTINE RMPIXB(X,Y,IX0,IY0)
C
C	GIVEN A PIXEL LOCATION ON THE RAMTEK, RETURNS THE LONGLIB
C	COORDINATE VALUE
C
	COMMON/RMTEK/ICHAN,IRM(128),RRE(2),ROX,ROY,RSF,NIRM,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
C
	IF (ICHAN.LT.0) RETURN
	COSA=COS(RANG*0.0174532)
	SINA=SIN(RANG*0.0174532)
	IY=IRYLIM-IY0
	X= ((FLOAT(IX0)*RRE(1)-ROX)*COSA+(FLOAT(IY)*RRE(2)-ROY)*SINA)/RSF
	Y=(-(FLOAT(IX0)*RRE(1)-ROX)*SINA+(FLOAT(IY)*RRE(2)-ROY)*COSA)/RSF
C
	RETURN
	END
C
C
	SUBROUTINE RMSIZE(XLEN,YLEN,NXSIZE,NYSIZE)
C
C	RETURNS RAMTEX SCREEN SIZE IN LONGLIB PACKAGE
C	  IN CURRENT PLOT UNITS (XLEN,YLEN)
C	  AND PIXELS (NXSIZE,NYSIZE)
C
	COMMON/RMTEK/ICHAN,IRM(128),RRE(2),ROX,ROY,RSF,NIRM,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
	IF (ICHAN.LT.0) RETURN
C
C	TRANSFORM INPUT POINT
C
	XLEN=IRXLIM*RRE(1)/RSF
	YLEN=IRYLIM*RRE(2)/RSF
	NXSIZE=IRXLIM
	NYSIZE=IRYLIM
C
	RETURN
	END
C
C
	SUBROUTINE RMSETSIZE(XLEN,YLEN,NXSIZE,NYSIZE)
C
C	RESETS THE RAMTEK SCREEN SIZE IN THE LONGLIB RAMTEK PACKAGE
C	  (XLEN,YLEN) IN PLOT UNITS  XLEN<1280, Y<1024
C	  (NXSIZE,NYSIZE) < (1280,1024) IN PIXELS
C	ORIGIN RESET TO (0,0) AND SCALE FACTOR RESET TO ZERO.
C	VIEWPORT RESET TO FULL SCREEN AND PLOT ANGLE RESET TO ZERO
C	PEN SHOULD BE UP BEFORE CALLING THIS ROUTINE
C
	COMMON/RMTEK/ICHAN,IRM(128),RRE(2),ROX,ROY,RSF,NIRM,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
	IF (ICHAN.LT.0) RETURN
C
C	TRANSFORM INPUT POINT
C
	IRXLIM=NXSIZE
	IRYLIM=NYSIZE
	RSF=1.0
	ROX=0.0
	ROY=0.0
	RANG=0.0
	RRE(1)=XLEN/IRXLIM
	RRE(2)=YLEN/IRYLIM
	RLIM(1)=IRXLIM
	RLIM(2)=IRYLIM
	RVP(1)=0.0		! VIEW PORT PARAMETERS
	RVP(2)=0.0		! LOWER LEFT
	CALL PLOTRM(999.,999.,4)! UPPER RIGHT
	RETURN
	END
C
C
	SUBROUTINE RAMMAP(IARRAY,NA,MA,N,M,IXS,IYS,BX,BY)
C
C	PROGRAM TO MAKE AN IMAGE MAP ON THE RAMTEK DEVICE
C
C	AUTHOR: DG LONG, JPL
C	DATE: 17 JAN 1991
C
C	INPUTS:
C	  IARRAY  : COLOR CODE (RAMTEK COLOR CODE NUMBERS)
C	  NA,MA	  : DIMENSIONS OF IARRAY
C	  N,M	  : PLOT N BY M PORTION OF IARRAY
C	  IXS,IYS : POSITION OF LOWER LEFT CORNER OF MAP (IN RAMTEK PIXELS)
C	  BX,BY   : BOX SIZE (IN RAMTEK PIXELS: 0 < BX < 1024)
C			IF BY < 0 REVERSE ARRAY
C
C	CALLS:
C	  RMPLOT
C
	INTEGER IARRAY(NA,MA)
	COMMON/RMTEK/ICHAN,IRM(128),RRE(2),ROX,ROY,RSF,NIRM,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
	INTEGER MPLOT(4)
	COMMON/ASTC/IASTFL,IASTPL			! CONTROL-C
	SAVE /ASTC/
C
C	MAKE MAP IN ROW ORDER FOR EFFICIENCIES SAKE
C
	IF (ICHAN.LT.0) RETURN
	DO 10 IX=1,N
		DO 5 IY1=1,M
			IASTPL=1			! CONTROL-C
			IY=IY1
			IF (BY.LT.0) IY=M-IY1+1
			JNT=IARRAY(IX,IY)
			MPLOT(1)=IXS+NINT(BX*(IX-1))
			MPLOT(2)=IYS+NINT(BY*(IY1-1))
			MPLOT(3)=IXS+NINT(BX*IX)
			MPLOT(4)=IYS+NINT(BY*IY1)
			CALL RAMBOX(ICHAN,MPLOT(1),MPLOT(2),
     $				MPLOT(3),MPLOT(4),JNT)
			IASTPL=0				! CONTROL-C
			IF (IASTFL.NE.0) CALL ASTINTER(IASTFL)	! CONTROL-C
5		CONTINUE
10	CONTINUE
C
	RETURN
	END 
C
C
	SUBROUTINE RAMMAP2(IARRAY,NA,MA,N,M,IXS,IYS,BX,BY)
C
C	PROGRAM TO MAKE AN IMAGE MAP ON THE RAMTEK DEVICE
C
C	AUTHOR: DG LONG, JPL
C	DATE: 17 JAN 1991
C
C	INPUTS:
C	  IARRAY  : COLOR CODE (RAMTEK COLOR CODE NUMBERS)
C	  NA,MA	  : DIMENSIONS OF IARRAY
C	  N,M	  : PLOT N BY M PORTION OF IARRAY
C	  IXS,IYS : POSITION OF LOWER LEFT CORNER OF MAP (IN RAMTEK PIXELS)
C	  BX,BY   : BOX SIZE (IN RAMTEK PIXELS: 0 < BX < 1024)
C			IF BY < 0 REVERSE ARRAY
C
C	CALLS:
C	  RMPLOT
C
	INTEGER*2 IARRAY(NA,MA)
	COMMON/RMTEK/ICHAN,IRM(128),RRE(2),ROX,ROY,RSF,NIRM,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
	COMMON/ASTC/IASTFL,IASTPL			! CONTROL-C
	SAVE /ASTC/
	INTEGER MPLOT(4)
C
C	MAKE MAP IN ROW ORDER FOR EFFICIENCIES SAKE
C
	IF (ICHAN.LT.0) RETURN
	DO 10 IX=1,N
		DO 5 IY1=1,M
			IY=IY1
			IF (BY.LT.0) IY=M-IY1+1
			JNT=IARRAY(IX,IY)
			MPLOT(1)=IXS+NINT(BX*(IX-1))
			MPLOT(2)=IYS+NINT(BY*(IY1-1))
			MPLOT(3)=IXS+NINT(BX*IX)
			MPLOT(4)=IYS+NINT(BY*IY1)
			CALL RAMBOX(ICHAN,MPLOT(1),MPLOT(2),
     $				MPLOT(3),MPLOT(4),JNT)
			IASTPL=0				! CONTROL-C
			IF (IASTFL.NE.0) CALL ASTINTER(IASTFL)	! CONTROL-C
5		CONTINUE
10	CONTINUE
C
	RETURN
	END 
