	PROGRAM LONGEPSF
C *** LAST REVISED ON  6-JAN-1995 09:22:28.44
C *** SOURCE FILE: [LONGD.GRAPHICS]LONGEPSF.FOR
C
C	MODIFIED FROM POSTSCRIP: DGL 5-JAN-1995
C	+ MAKES ENCAPSULATED POSTSCRIPT FILE WITH SCALING, ROTATION OPTIONS
C
C	THIS PROGRAM CONVERTS THE LONGLIB METAFILE PRODUCED BY THE
C	LONGLIB93  GRAPHICS LIBRARY INTO ENCAPSULATED POSTSCRIPT
C
	CHARACTER*80 NAME
C
C	VAX DEPENDENT ROUTINE TO GET COMMAND LINE FILE NAME
C	(CAN BE COMMENTED OUT)
C
cc	IERR=LIB$GET_FOREIGN(NAME,,IFLAG)
C
C	DEFAULT NAME
C
cc	if (name.eq.' ') then
cc		NAME='for003.dat'	! VAX DEFAULT FILE NAME
cc		NAME='ftn03'		! UNIX DEFAULT FILE NAME
		NAME='fort.3'		! LINUX g77 DEFAULT FILE NAME
cc	endif
	CALL LPLOT(NAME)
	STOP
	END
C
C
	SUBROUTINE LPLOT(NAME)
C
C	MAIN ROUTINE TO CONVERT PRINTER GRAPHICS FILE TO POSTSCRIPT EPS
C
C	NAME	(CHARACTER)	FILE NAME
C
	CHARACTER*(*) NAME
C
C	DEFINITIONS FOR LINE TYPES
C
	CHARACTER*13 LINETYPE(10)
	DATA LINETYPE(1)/'[]'/,LINETYPE(2)/'[2]'/,LINETYPE(3)/'[4 4]'/
	DATA LINETYPE(4)/'[4 7]'/,LINETYPE(5)/'[2 2]'/
	DATA LINETYPE(6)/'[2 2 2 2 4]'/,LINETYPE(7)/'[6 2 3 2 4]'/
	DATA LINETYPE(8)/'[1 1]'/,LINETYPE(9)/'[1 1 4 4]'/
	DATA LINETYPE(10)/'[1 1 2 2 3 3]'/
C
	INTEGER PENUP
	LOGICAL ROTATE
	LOGICAL YESNO2
C
C	OPEN INPUT FILE PRODUCED BY LONGLIB GRAPHICS LIBRARY
C
	OPEN(UNIT=2,FILE=NAME,FORM='UNFORMATTED',STATUS='OLD')
C     $		ERR=99,READONLY)
C
	WRITE (*,*) 'Reading ',NAME
C
C	MAKE ONE PASS THROUGH FILE TO DETERMINE MAX/MIN X,Y POSITIONS
C
	XMIN= 1.E25
	XMAX=-1.E25
	YMIN= 1.E25
	YMAX=-1.E25
	NPAGE=1
	IPCNT=0
	MP=999
C
	CALL REGET(M1,M2,M3,MP,2)
	IF (M3.EQ.11) GOTO 8110
	SX=M1
	SY=M2
	IF (M1.EQ.0.OR.M2.EQ.0) GOTO 8110
8001	CONTINUE
C
	CALL REGET(M1,M2,M3,MP,2)
C
8002	Y1=M1/SX
	X1=M2/SY
	I3=M3
C
	IF (I3.GT.1050) GOTO 8999
	IF (I3.GT.999) GOTO 8001
	GOTO (8001,8020,8001,8001,8001,8001,8001,8001,8020,8100,8110) I3
C
8020	CONTINUE	!	MOVE PENDOWN COMMAND "CALL PLOT(X1,Y1,2)"
	IPCNT=IPCNT+1
	XMAX=MAX(XMAX,X1)
	XMIN=MIN(XMIN,X1)
	YMAX=MAX(YMAX,Y1)
	YMIN=MIN(YMIN,Y1)
	GOTO 8001
C
8100	CONTINUE	! NEW PAGE COMMAND
	IPCNT=0
	NPAGE=NPAGE+1
	GOTO 8001
C
8999	CONTINUE	! IMAGE MODE (ANY PEN CHANGES IGNORED)
C
	IF (I3.EQ.2000) THEN
		Y1=M1/SX
		X1=M2/SY
		XMAX=MAX(XMAX,X1)
		XMIN=MIN(XMIN,X1)
		YMAX=MAX(YMAX,Y1)
		YMIN=MIN(YMIN,Y1)
		AMX=X1*288
		AMY=Y1*288
	ENDIF
	IF (I3.EQ.2001) THEN
		INX=M1
		IF (INX.LT.1) INX=1
		INY=M2
		IF (INY.LT.1) INY=1
		X1=X1+FLOAT(INX)/288.0
		Y1=Y1+FLOAT(INY)/288.0
C
C	SKIP IMAGE DATA
C		
		NUM=INX*INY
		IF (MOD(NUM,2).EQ.1) NUM=NUM+1
		NUM=NUM/2
		DO 82002 I=1,NUM
			CALL REGET(M1,M2,M3,MP,2)
			IF (M3.NE.2002) GOTO 8002
82002		CONTINUE
	ENDIF
	GOTO 8001
C
C	REWIND INPUT FILE
C
8110	CONTINUE
	REWIND(2)
	IF (IPCNT.EQ.0.AND.NPAGE.GT.1) NPAGE=NPAGE-1
C
C	PRINT IMAGE SIZE
C
	IF (NPAGE.GT.1) WRITE (*,*) 'Pages:  ',NPAGE
	WRITE (*,*) 'X Range:',XMIN,XMAX
	WRITE (*,*) 'Y Range:',YMIN,YMAX
	IF (XMIN.GT.1.E24) XMIN=0.0
	IF (YMIN.GT.1.E24) YMIN=0.0
	IF (XMAX.LE.XMIN) XMAX=XMIN+0.1
	IF (YMAX.LE.YMIN) YMAX=YMIN+0.1
C
C	PROMPT FOR USER SCALING INFORMATION
C
	SCALE=1.0
	ROTATE=.FALSE.
	XOFF=0.0
	YOFF=0.0
C
	WRITE (*,8500)
8500	FORMAT(' Landscape (N) or Portrait (Y): ',$)
	ROTATE=YESNO2(.FALSE.,IEND)
	IF (IEND.LT.0) GOTO 99
	IF (ROTATE) SCALE=0.8
	WRITE (*,8510)
8510	FORMAT(' Scale Factor: ',$)
	SCALE=READVAL1(SCALE,IEND)
	IF (IEND.LT.0) GOTO 99
	WRITE (*,8520)
8520	FORMAT(' Change relative origin: ',$)
	IF (YESNO2(.FALSE.,IEND)) THEN
		WRITE (*,8530)
8530		FORMAT(' X offset: ',$)
		XOFF=READVAL1(XOFF,IEND)
		IF (IEND.LT.0) GOTO 99
		WRITE (*,8540)
8540		FORMAT(' Y offset: ',$)
		YOFF=READVAL1(YOFF,IEND)
		IF (IEND.LT.0) GOTO 99
	ENDIF
	IF (IEND.LT.0) GOTO 99
C
C	COMPUTE BOUNDING BOX
C
	XMIN=SCALE*XMIN+XOFF
	YMIN=SCALE*YMIN+YOFF
	XMAX=SCALE*XMAX+XOFF
	YMAX=SCALE*YMAX+YOFF
	IF (ROTATE) THEN
		IXMIN=IFIX(XMIN*72)
		IYMIN=IFIX(YMIN*72)
		IXMAX=IFIX(XMAX*72)+1
		IYMAX=IFIX(YMAX*72)+1
	ELSE
		IXMIN=IFIX(YMIN*72)
		IYMIN=780-IFIX(XMAX*72)-1
		IXMAX=IFIX(YMAX*72)+1
		IYMAX=780-IFIX(XMIN*72)
	ENDIF
C
C	OPEN OUTPUT FILE
C
	OPEN(UNIT=1,FILE='out.eps',FORM='FORMATTED',STATUS='NEW')
C
C	SEND INITIALIZATION CODES TO OUTPUT FILE
C
 	WRITE (1,200) IXMIN,IYMIN,IXMAX,IYMAX,NPAGE
200	FORMAT('%!PS-Adobe-2.0 EPSF-1.2',
     $	/'%%Title: ENCAPSULATED PostScript for LongLib',
     $	/'%%Creator: D. Long VAX VMS (POSTSCRIPT)',
     $	/'%%Creation Date: Thu Jan 5, 1995',
     $  /'%%Bounding Box:',4(1X,I4)
     $	/'%%Pages: ',I2,
     $	/'%%EndComments',
     $	/' % Function definitions to reduce filesize',
     $	/' /g { grestore showpage } bind def',
     $	/' /l { lineto } bind def',
     $	/' /m { moveto } bind def',
     $	/' /s { moveto closepath stroke } bind def',
     $	/' /n { newpath } bind def',
     $	/' /i { image grestore } bind def',
     $	/' /d { setdash } bind def',
     $	/'%%Page: 1 1')
 	WRITE (1,300)
300	FORMAT(	1X,'1 setlinejoin',	! LINE JOIN TYPE
     $		1X,'0 setlinecap',	! LINE END CAP
     $		1X,'[] 0 setdash',	! SOLID LINE
     $		1X,'0 setlinewidth',	! SINGLE LINE WIDTH
     $		1X,'0 setgray',/	! BLACK LINE
     $		1X,'0.25 0.25 scale',	! SCALE TO 288 DOTS/INCH
     $		1X,'gsave')
C
C	INITIALIZE VARIABLES
C
	LW=-1		! LINE WIDTH (INVALID TO FORCE NEW WIDTH)
	LT=-1		! LINE TYPE (INVALID TO FORCE NEW TYPE)
	LC=-1		! LINE COLOR (INVALID TO FORCE NEW TYPE)
C
	AMX=288.0
	AMY=288.0
	MP=999
	IXOLD=0
	IYOLD=0
	JPCNT=0
	JPS = 1
C
C	PENUP IS PEN CONTROL FLAG (0=NO SEGMENT, 2=PEN UP, 3=PEN DOWN)
C
	PENUP=0
C
C	TOP OF LONGLIB META-FILE READ LOOP
C
1000	CONTINUE
C
C	READ INITIAL COMMAND CODE AND PARAMETERS FROM LONGLIB META-FILE
C
	CALL REGET(M1,M2,M3,MP,2)
C
C	CHECK END OF FILE
C
	IF (M3.EQ.11) GOTO 110
	SX=M1
	SY=M2
	IF (M1.EQ.0.OR.M2.EQ.0) GOTO 110
  1	CONTINUE
C
C	READ COMMAND CODE AND PARAMETERS FROM LONGLIB META-FILE
C
	CALL REGET(M1,M2,M3,MP,2)
C
C	COORDINATE TRANSFORM
C
  2	Y1=SCALE*M1/SX+XOFF
	X1=SCALE*M2/SY+YOFF
	I3=M3
	IOLD=-1
C
C	CHECK END OF FILE
C
	IF (M3.GT.999) GOTO 999
C
C	EXECUTE META-FILE COMMAND
C
	GOTO (10,20,20,10,10,10,10,10,20,100,110) I3
10	GOTO 1
C
C	INTERPRET COMMAND
C
20	CONTINUE
C
C	"CALL PLOT(X1,Y1,I3)"
C
C	CONVERT TO INTEGER 0.25/72'S INCH
C
	IF (ROTATE) THEN
cc		IX=INT(X1*72+0.5)+5
cc		IY=INT(Y1*72+0.5)
		IX=INT(X1*288+0.5)+5
		IY=INT(Y1*288+0.5)
	ELSE
cc		IX=INT(Y1*72+0.5)+5
cc		IY=780-INT(X1*72+0.5)
		IX=INT(Y1*288+0.5)+5
		IY=3120-INT(X1*288+0.5)
		IF (IY.LT.0) IY=0
	ENDIF
	IF (I3.EQ.3) THEN
C
C	PEN UP MOVE
C
		IF (PENUP.EQ.2) THEN
			KX=IDIGITS(IXOLD)
			KY=IDIGITS(IYOLD)
			WRITE (1,601) IXOLD,IYOLD
cc601			FORMAT(1X,I<KX>,1X,I<KY>,' moveto closepath stroke')
601			FORMAT(1X,I<KX>,1X,I<KY>,' s')
		ENDIF
		PENUP=3
		JPCNT=0
	ELSE
C
C	PEN DOWN MOVE
C 				! PEN DOWN MOVE
		IF (PENUP.EQ.3) THEN
			KX=IDIGITS(IXOLD)
			KY=IDIGITS(IYOLD)
			WRITE (1,600) IXOLD,IYOLD
cc600			FORMAT(1X,'newpath ',I<KX>,1X,I<KY>,' moveto')
600			FORMAT(1X,'n ',I<KX>,1X,I<KY>,' m')
			JPCNT=0
		ENDIF
		PENUP=2
		KX=IDIGITS(IX)
		KY=IDIGITS(IY)
C
C	OUTPUT LINE CONTINUATION.  IF # POINTS EXCEEDS 256, OUTPUT
C	ALSO, DON'T OUTPUT REDUNDANT POINTS
C
		IF (JPCNT.GT.256) THEN
			WRITE (1,601) IX,IY
			WRITE (1,600) IX,IY
			JPCNT=0
		ELSE
			IF (JPCNT.EQ.0.OR.(IX.NE.IXOLD.OR.IY.NE.IYOLD)) THEN
				WRITE (1,603) IX,IY
cc603				FORMAT(1X,I<KX>,1X,I<KY>,1X,'lineto')
603				FORMAT(1X,I<KX>,1X,I<KY>,1X,'l')
				JPCNT=JPCNT+1
			ENDIF
		ENDIF
	ENDIF
	IXOLD=IX
	IYOLD=IY
	GOTO 1
C
100	CONTINUE
C
C	"CALL NEWPAGE"
C
	IF (PENUP.EQ.2) THEN
		KX=IDIGITS(IXOLD)
		KY=IDIGITS(IYOLD)
		WRITE (1,601) IXOLD,IYOLD
		PENUP=0
		JPCNT=0
	ENDIF
	JPS = JPS+1
	IF (JPS.LE.NPAGE) THEN
		WRITE (1,402) JPS,JPS
cc402		FORMAT(1X,'grestore showpage',
402		FORMAT(1X,'g',
     $			/'%%Page: ',I2,1X,I2/
     $			1X,'0.25 0.25 scale'	! SCALE TO 288 DOTS/INCH
     $			1X,'gsave')
		WRITE (1,403) LINETYPE(LT+1)
		WRITE (1,404) LW-1
	ENDIF
	GOTO 1
C
C	SPECIAL COMMANDS
C
999	CONTINUE
	JPCNT=0
	IF (I3.GT.1999) GOTO 1999
	GOTO (1000,1001,1002,1003) I3-999
998	GOTO 1
C
C	NEW PEN/LINE TYPE
C
1001	CONTINUE
	IF (M1.LT.0) M1=0
	IF (M1.GT.9) M1=MOD(M1,10)
	IF (M1.NE.LT) THEN
		IF (PENUP.EQ.2) THEN
			KX=IDIGITS(IXOLD)
			KY=IDIGITS(IYOLD)
			WRITE (1,601) IXOLD,IYOLD
			PENUP=0
		ENDIF
		WRITE (1,403) LINETYPE(M1+1)
		LT=M1
	ENDIF
cc403	FORMAT(1X,A13,' 0 setdash')
403	FORMAT(1X,A13,' 0 d')
	GOTO 1
C
C	LINE COLOR
C
1002	CONTINUE
c	LW=M1
C
C	INCLUDE PEN COLOR AS GRAY SCALE (0-16) BLACK=16, WHITE=0
C
	IF (M2.NE.LC) THEN
C
C	"CALL PLOT(FLOAT(M2),0.,0)"
C
C		WRITE (1,407) FLOAT(M2-1)/16.
C 407		FORMAT(1X,F4.2,' setgray')
	ENDIF
	LC=M2
	GOTO 1
C
C	LINEWIDTH
C
1003	CONTINUE
C
C	"CALL NEWPEN(I3)"
C
	IF (M1.LE.0) M1=1
C
C	NOTE: THE LINEWIDTH IS GRAPHICS DEVICE DEPENDENT AND MAY VARY
C	DEPENDING ON LINE ORIENTATION
C
	IF (M1.NE.LW) THEN
		IF (PENUP.EQ.2) THEN
			KX=IDIGITS(IXOLD)
			KY=IDIGITS(IYOLD)
			WRITE (1,601) IXOLD,IYOLD
			PENUP=0
		ENDIF
C
C	NEW LINE WIDTH
C
		WRITE (1,404) M1
404		FORMAT(1X,I2,' setlinewidth')
		LW=M1
	ENDIF
	GOTO 1
C
C	IMAGE MODE
C
1999	CONTINUE
C
C	CHECK EACH OPTION
C
	IF (I3.EQ.2000) THEN
		Y1=SCALE*M1/SX
		X1=SCALE*M2/SY
		AMX=X1*288
		AMY=Y1*288
	ENDIF
	IF (I3.EQ.2001) THEN
		INX=M1
		IF (INX.LT.1) INX=1
		INY=M2
		IF (INY.LT.1) INY=1
		NUM=INX*INY
		IF (ROTATE) THEN
		  IY=NINT(AMY)
		  WRITE (1,2021) IXOLD,IYOLD,AMY,AMX,INY,INX, INX,INY
2021		  FORMAT(' gsave ',I4,1X,I4,' translate ',F10.4,1X,F10.4,' scale '/
     $			1X,I4,1X,I4,' 8 [0 ',I4,I4,' 0 0 0 ] {<')
C     $			1X,I4,1X,I4,' 8 [',I4,' 0 0 ',I4,' 0 0 ] {<')
C     $			1X,I4,1X,I4,' 8 [ 0 ',I4,' ',I4,' 0 ',I4,' 0 ] {<')
		ELSE
		  IY=IYOLD-NINT(AMY)
		  WRITE (1,2020) IXOLD,IY,AMX,AMY,INY,INX,INY,-INX,INX
2020		  FORMAT(' gsave ',I4,1X,I4,' translate ',F10.4,1X,F10.4,' scale '/
     $			1X,I4,1X,I4,' 8 [',I4,' 0 0 ',I4,' 0 ',I4,'] {<')
		ENDIF
C
C	READ IMAGE DATA AND CONVERT TO HEXIDECIMAL
C		
		IF (MOD(NUM,2).EQ.1) NUM=NUM+1
		NUM=NUM/2
		IC=0
		DO 2002 I=1,NUM
			CALL REGET(M1,M2,M3,MP,2)
			IF (M3.NE.2002) GOTO 2
			CALL HEXIT(M1,M2,IC)
2002		CONTINUE
		IF (IC.GT.0) CALL HEXIT(M1,M2,-IC)
		WRITE (1,2030)
cc2030		FORMAT(' >} image grestore')
2030		FORMAT(' >} i')
	ENDIF
	GOTO 1
C
C	CLOSE INPUT FILE
C
110	CLOSE(2)
C
	IF (PENUP.EQ.2) THEN
		KX=IDIGITS(IXOLD)
		KY=IDIGITS(IYOLD)
		WRITE (1,601) IXOLD,IYOLD
		PENUP=0
	ENDIF
C
	WRITE (1,410) JPS
cc410	FORMAT(1X,'grestore showpage',
410	FORMAT(1X,'g',
     $	/'%Trailer',
     $	/'%Pages: ',I2,1X,'1',
     $	/)
C
C	CLOSE OUTPUT FILE
C
	CLOSE(1)
 99	RETURN
	END
C
	SUBROUTINE REGET(M1,M2,M3,MP,ILU)
C
C	READ DATA FROM LONGLIB META-FILE PRINTER DATA FILE
C	
	INTEGER*2 M(128)
	MP=MP+3
	IF (MP.GT.128) THEN
		READ (ILU,ERR=99) M
		MP=3
	ENDIF
	M3=M(MP)
	M2=M(MP-1)
	M1=M(MP-2)
	IF (M3.EQ.999) GOTO 99
	RETURN
99	M3=11
	RETURN
	END
C
C
	INTEGER FUNCTION IDIGITS(I)
	N=1
	IF (I.GT.9) N=N+1
	IF (I.GT.99) N=N+1
	IF (I.GT.999) N=N+1
	IF (I.GT.9999) N=N+1
	IDIGITS=N
	RETURN
	END
C
C
	SUBROUTINE HEXIT(I,J,IC)
	INTEGER C(38)
	IF (IC.EQ.0) ICNT=1
	IF (IC.LT.0) THEN		! DUMP OUTPUT BUFFER
		IF (ICNT.GT.1) WRITE (1,10) (C(I),I=1,ICNT-1)
		ICNT=1
		GOTO 100
	ENDIF
	IC=1
	C(ICNT)=I
	IF (C(ICNT).LT.0) C(ICNT)=0
	IF (C(ICNT).GT.255) C(ICNT)=255
	ICNT=ICNT+1
	C(ICNT)=J
	IF (C(ICNT).LT.0) C(ICNT)=0
	IF (C(ICNT).GT.255) C(ICNT)=255
	ICNT=ICNT+1
	IF (ICNT.GE.38) THEN
		WRITE (1,10) (C(I),I=1,38)
		ICNT=1
	ENDIF
10	FORMAT(1X,38Z2.2)
100	RETURN
	END

	
	LOGICAL FUNCTION YESNO2(DEFAULT,IEND)
C
C	READS TERMINAL USING FORTRAN "ACCEPT" FOR A CHARACTER AND RETURNS
C	"PRINT"S OUT DEFAULT VALUE
C	.TRUE. = YES  .FALSE. = NO
C	DEFAULT IS FOR WHEN ONLY RETURN IS PRESSED
C	THIS VERSION INCORPORATES AN END FLAG AND MORE OPTIONS
C
	LOGICAL DEFAULT
	character*1 ANS
C
	IEND=0
	YESNO2=DEFAULT
	IF (DEFAULT) THEN
		PRINT 2
2		FORMAT(' (Y/N) [Y] ',$)
	ELSE
		PRINT 3
3		FORMAT(' (Y/N) [N] ',$)
	ENDIF
	READ (*,1,END=99,ERR=99) ANS
1	FORMAT(A1)
	IF (ANS.EQ.'Y'.OR.ANS.EQ.'y') YESNO2=.TRUE.
	IF (ANS.EQ.'T'.OR.ANS.EQ.'t') YESNO2=.TRUE.
	IF (ANS.EQ.'N'.OR.ANS.EQ.'n') YESNO2=.FALSE.
	IF (ANS.EQ.'F'.OR.ANS.EQ.'f') YESNO2=.FALSE.
	IF (ANS.EQ.'X'.OR.ANS.EQ.'x') GOTO 99
	IF (ANS.EQ.'E'.OR.ANS.EQ.'e') GOTO 99
	GOTO 100
99	IEND=-1		! ERROR RETURN
100	RETURN
	END
