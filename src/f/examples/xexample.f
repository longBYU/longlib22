	PROGRAM XEXAMPLE
C *** LAST REVISED ON 23-JAN-1994 05:53:19.33
C *** SOURCE FILE: [LONGD]XEXAMPLE.FOR
C
	PARAMETER (MAXSIZE=70000)
	REAL 		STVAL(MAXSIZE)
	INTEGER*2	ISTVAL(MAXSIZE)
	INTEGER		RAMID(4)
	LOGICAL CUSTOM
C
	WRITE (*,*) 'Ramtek X Windows Demo Program'
	CUSTOM=.TRUE.
C
C	CREATE A FLOATING POINT IMAGE
C
	NSX=256
	NSY=256
	DO 10 I=1,NSX
		ARGX=2*(I-1)*3.141592654/FLOAT(NSX)
		DO 10 J=1,NSY
			INDEX=I+(J-1)*NSX
			ARGY=2*(J-1)*3.141592654/FLOAT(NSY)
			STVAL(INDEX)=SIN(ARGX)*SIN(ARGY)
10	CONTINUE
C
C	SET MAX AND MIN PLOTTING VALUES
C
	SMIN=-1.0
	SMAX=1.0
C
C	OPEN PLOT PACKAGE
C
	IF (.NOT.CUSTOM) THEN
C
C	CREATE STANDARD RAMTEK WINDOW SIZE
C
		CALL FRAME(-3,-1,0.33,0.78,1.)
	ELSE
C
C	CRATE CUSTOM SIZED WINDOW
C
		RAMID(1)=101		! RAMTEK DEVICE/WINDOW (101=CUSTOM)
		RAMID(2)=NSX+50		! CUSTOM RAMTEK X DIMENSION IN PIXELS
		RAMID(3)=NSY+120	! CUSTOM RAMTEK Y DIMENSION IN PIXELS
		RAMID(4)=11		! WINDOW XWIDTH IN INCHES
C
		WRITE (*,*) 'Creating Custom Ramtek Window:',RAMID(2),RAMID(3),RAMID(4)
C
C	INITIALIZE RAMTEK DEVICE (BY DEFAULT, META AND TERMINAL PACKAGES ARE OFF)
C
		CALL RPLOTS(RAMID,0.33,0.58,1.0)
	ENDIF
	CALL CTERM(1)
C
C	GET CHANNEL AND/OR WINDOW NUMBER
C
	ICHAN=IRMCHAN(ID)
	IF (ICHAN.LE.0) THEN				! RAMTEK NOT OPENED
		CALL PLOTND
		CALL EXIT(0)
	ENDIF
C
C	IF (ICHAN.NE.99999) THEN
	  CALL RMSTCOL(ICHAN,1,NCOL,IERR)	! STORE STANDARD COLOR TABLE
	  CALL PLOT(0.,0.5,-3)			! MOVE ORIGIN
C	ENDIF
C
C	GET SIZE OF DISPLAY IN INCHES AND PIXELS
C
	CALL RMSIZE(XSIZE,YSIZE,NX,NY)
	WRITE (*,*) 'SIZE IN INCHES:',XSIZE,YSIZE
	WRITE (*,*) 'MAX PIXEL:     ',NX,NY
C
C	GET PIXEL TO INCH TRANSFORMATION INFO
C
	CALL RMPIX(0.,0.,IXR,IYR)
	WRITE (*,*) 'ORIGIN PIXEL:  ',IXR,IYR
	CALL RMPIX(1.,1.,IXR1,IYR1)
	WRITE (*,*) 'UNIT POINT:    ',IXR1,IYR1
	IXR=IXR+ISIGN(1,IXR1-IXR)
	IYR=IYR+ISIGN(1,IYR1-IYR)
	NXSPACE=NX-IXR
	IF (IXR1-IXR.LT.0) NXSPACE=IXR
	NYSPACE=NY-IYR
	IF (IYR1-IYR.LT.0) NYSPACE=IYR
	WRITE (*,*) 'SIZE IN PIXELS:',NXSPACE,NYSPACE
	IF (NXSPACE.LT.NSX.OR.NYSPACE.LT.NSY) THEN
		WRITE (*,*) '*** CAN NOT DISPLAY FULL IMAGE **'
		NSX=NXSPACE
		NSY=NYSPACE
	ENDIF
	NXOFF=IXR+ISIGN(NSX,IXR1-IXR)
	NYOFF=IYR+ISIGN(NSY,IYR1-IYR)
	CALL RMPIXB(XSIZE,YSIZE,NXOFF,NYOFF)
	NXOFF=NXOFF-ISIGN(1,IXR1-IXR)
	NYOFF=NYOFF-ISIGN(1,IYR1-IYR)
	IURX=NXOFF
	IURY=IYR
	ILLX=IXR
	ILLY=NYOFF
	WRITE (*,*) 'LOWER-LEFT:    ',ILLX,ILLY
	WRITE (*,*) 'UPPER-RIGHT:   ',IURX,IURY
	XSC=XSIZE/NSX
	YSC=YSIZE/NSY
C
	DS=SMAX-SMIN
	IF (DS.EQ.0.0) DS=1.0
	DS=1.0/DS
C
C	LOAD OUTPUT ARRAY WITH COLOR INDEXES
C
	DO NN1=0,NSY-1
	    DO NN2=0,NSX-1
		INDEX = NN1*NSX+NN2+1
		Z = STVAL(INDEX)
		DEL=(Z-SMIN)*DS
		IF (DEL.GT.128.5) DEL=128.5
		IF (DEL.LT.-128.5) DEL=-128.5
		IVAL=ANINT(DEL*(NCOL-2))+2
		IF (IVAL.GT.NCOL-2) IVAL=NCOL-2
		IF (IVAL.LT.1)   IVAL=1
		ISTVAL(INDEX)=IVAL
	    END DO
	END DO
C
	WRITE (*,*) 'Begin Plotting'
C
C	DRAW IMAGE BOUNDARY
C
	CALL RECT(0.,0.,XSIZE,YSIZE)
	CALL PLOT(0.,0.,5)
C
C	NOW DISPLAY ARRAY USING RMWRITEWORD
C
	CALL RMWIND(ICHAN,ILLX,ILLY,IURX,IURY)
	CALL RMDIR(ICHAN,2,IERR)
	CALL RMSTART(ICHAN,ILLX,ILLY)
	CALL RMWRITEWORD(ICHAN,ISTVAL,NSX*NSY,IERR)
C
C	ADD AXES
C
	AF=FLOAT(NSX/32)+1.01
	XLL=0.0
	XHH=NSX
	XLEN=XSIZE
	CALL AXIS3(0.,0.,'X',-1,XLEN,0.,XLL,XHH,AF,-0.12,1003.)
	CALL AXIS3(0.,YSIZE,'X',101,XLEN,0.,XLL,XHH,AF,-0.12,1003.)
C
	AF=FLOAT(NSY/32)+1.01
	YLL=0.0
	YHH=NSY
	YLEN=YSIZE
	CALL AXIS3(0.,0.,'Y',1,YLEN,90.,YLL,YHH,AF,-0.12,1003.)
	CALL AXIS3(XSIZE,0.,'Y',-101,YLEN,90.,YLL,YHH,AF,-0.12,1003.)

	print *,'here ncol=',ncol
	!call rterm(2)
	ncol=256
	
C
C	GENERATE AND DISPLAY COLOR (GREYSCALE) BAR USING RAMMAP
C
	DO I=2,NCOL-1
		ISTVAL(I-1)=I
	END DO
	CLEN=3.0
	CALL PLOT(0.5,-0.75,-3)
	CALL RMPIX(0.,0.25,IXR,IYR)
	CALL RMPIX(CLEN,0.0,IX1,IY1)
	RJX=FLOAT(IABS(IX1-IXR))/FLOAT(NCOL-2)
	RJY=FLOAT(IY1-IYR)
	
	CALL RAMMAP2(ISTVAL,NCOL-2,1,NCOL-2,1,IXR,IYR,RJX,RJY)
        !call rambox3(ichan,25,25,150,150,128)
	
	IDRX=RJX*(NCOL-2)
	CALL RMPIXB(CLEN,Y1,IXR+IDRX,IY1)
	CALL RECT(0.,0.0,CLEN,0.25)
C       
C	LABEL END OF BAR
C
	CALL NUMBER(-0.12*1.5,0.29,0.12,SMIN,0.,1003.,-1)
	CALL NUMBER(CLEN-0.12*1.5, 0.29,0.12,SMAX,0.,1003.,-1)
	DEL=SMAX-SMIN
	N=2
C       
C	LABEL INTERIOR POINTS OF BAR
C
	DO I=1,N-1
	    S=I*DEL/FLOAT(N)
	    XVAL=3.0*S/(SMAX-SMIN)
	    CALL PLOT(XVAL,0.0,3)
	    CALL PLOT(XVAL,0.25,2)
	    CALL NUMBER(XVAL-0.12*1.5,0.29,0.12,S+SMIN,0.,1003.,-1)
	END DO
C       
C	ADD OTHER INFORMATION
C
	CALL SYMBOL(-0.15,-0.50,0.2,'BYU',0.,3,-1)
	CALL PLOT(0.,-0.65,-3)
	CALL PLOT(-0.5,0.75,-3)
C
C	EVENT LOOP FOR OPTIONS
C
	call rterm(2)
	IF (ICHAN.NE.99999) THEN
4		CONTINUE
		write (*,*)
		WRITE (*,*) 'Type any key in focused window to exit program'
		WRITE (*,*) '  Press right button to change color table'
		WRITE (*,*) '  Press center button to edit color table'
		WRITE (*,*) '  Press left button to focus and get position/value'
414		CALL RMREADCURSOR(ICHAN,0,IX,IY,ITRK,0,IENT,IERR)
		IF (IENT.EQ.3) THEN ! RIGHT BUTTON
			CALL RMPAUSE(ICHAN,0)
			WRITE (*,*) 'New Color Table:'
			CALL COLORTABLE(ICHAN,NCOL)
C
			CALL PLOT(0.,0.,5)
			CALL RMMODE(ICHAN,.TRUE.,.FALSE.,.FALSE.,IERR)
			CALL RECT(4.,4.,6.,6.)
			CALL PLOT(0.,0.,5)
			CALL RMMODE(ICHAN,.TRUE.,.TRUE.,.FALSE.,IERR)
			CALL RMPAUSE(ICHAN,0)
			GOTO 4
		ELSE IF (IENT.EQ.2) THEN ! CENTER BUTTON
			CALL RMPAUSE(ICHAN,0)
			WRITE (*,*) 'Edit Color Table:'
			CALL EDITCOLORTABLE(ICHAN,NCOL)
			CALL RMPAUSE(ICHAN,0)
			GOTO 4
		ELSE IF (IENT.EQ.1) THEN ! LEFT (FOCUS) BUTTON
			IF (IX-ILLX.GE.0.AND.IURY-IY.GE.0.AND.
     $			    IX-ILLX.LT.NSX.AND.IURY-IY.LE.NSY) THEN
				I=( (IURY-IY) * NSX ) + (IX-ILLX) + 1
				WRITE (*,603) IX-ILLX,IURY-IY,ISTVAL(I),
     $					ISTVAL(I)/FLOAT(NCOL)*(SMAX-SMIN)+SMIN
603			FORMAT(' Pix: (',I4,',',I4,')   Val:',I4,' = ',F6.3)
			ENDIF
			CALL RMMODE(ICHAN,.TRUE.,.TRUE.,.TRUE.,IERR)
			GOTO 414
		ENDIF
	ELSE
		CALL RMPAUSE(ICHAN,1)
		CALL RTERM(-2)
	ENDIF
C
	CALL PLOTND
	STOP
	END
C
C
	SUBROUTINE COLORTABLE(ICHAN,NCOL)
	CHARACTER*80 CNAME
	IF (ICHAN.LE.0) RETURN
C
10	WRITE (*,44)
44	FORMAT(' Color table file: (BLANK=NONE) ',$)
	READ (*,15) CNAME
15	FORMAT(A80)
C
	IF (ICHAN.NE.99999) THEN
		 IF (NCOL.GT.256) NCOL=255
		 IF (CNAME.NE.' ') THEN
		  I=-1
		  OPEN(2,ERR=99,FILE=CNAME,STATUS='OLD',FORM='FORMATTED')
		  I=0
		  READ(2,'(I4)',ERR=98) NCOL1
		  WRITE (*,*) 'COLOR TABLE ENTRIES:',NCOL1
		  DO I=1,NCOL1
			READ(2,'(3I4)',ERR=98) IRED,IGREEN,IBLUE
			IRED=IRED*128
			IGREEN=IGREEN*128
			IBLUE=IBLUE*128
			IF (I.LE.NCOL) THEN
				CALL RMWRCOLIND(ICHAN,IRED,IGREEN,
     $						IBLUE,I,IERR)
			ENDIF
		  END DO
		  CLOSE(2)
		 ENDIF
	ENDIF
	RETURN
98	WRITE (*,*) '*** READ ERROR ***'
99	WRITE (*,*) '*** COLOR TABLE FILE ERROR ***'
	WRITE (*,*) '"',CNAME,'"',I
	GOTO 10
	END
C
	SUBROUTINE EDITCOLORTABLE(ICHAN,NCOL)
	CHARACTER*80 CNAME
	IF (ICHAN.LE.0) RETURN
	IF (ICHAN.EQ.99999) RETURN
C
	WRITE (*,*) 'EDIT COLOR TABLE  MAX COLORS:',NCOL
	INDEX=0
10	CONTINUE
	CALL RMPAUSE(ICHAN,0)
	WRITE (*,44)
44	FORMAT(' Index Number: (-1=SAVE TABLE, OR 0=EXIT EDIT) ',$)
	INDEX=IREADVAL1(INDEX+1,IEND)
	IF (INDEX.EQ.-1) THEN
		WRITE (*,55)
55		FORMAT(' Enter output file name: ',$)
		READ (*,56) CNAME
56		FORMAT(A80)
		OPEN(2,FILE=CNAME,STATUS='NEW',FORM='FORMATTED')
		WRITE (2,'(I4)') NCOL
		DO I=1,NCOL
		  CALL RMRDCOLIND(ICHAN,IRED,IGREEN,IBLUE,I,IERR)
		  IRED=IRED/128
		  IGREEN=IGREEN/128
		  IBLUE=IBLUE/128
		  WRITE (2,'(3I4)') IRED,IGREEN,IBLUE
		END DO
		CLOSE(2)
		CALL RMPAUSE(ICHAN,0)
	ENDIF
	IF (IEND.LT.0.OR.INDEX.LE.0) RETURN
	INDEX=MIN(INDEX,NCOL)
C
	CALL RMRDCOLIND(ICHAN,IRED,IGREEN,IBLUE,INDEX,IERR)
	IRED=IRED/128
	IGREEN=IGREEN/128
	IBLUE=IBLUE/128
	WRITE (*,100) INDEX,IRED,IGREEN,IBLUE
100	FORMAT(' Index->',I4,'  R:',I3,'  G:',I3,'  B:',I3)
C
	CALL RMPAUSE(ICHAN,0)
	WRITE (*,45) 'Red  ',IRED
45	FORMAT(1X,A5,' Value: [',I3,']: ',$)
	IRED=MIN(NCOL,MAX(IREADVAL1(IRED,IEND),0))
	IF (IEND.LT.0) GOTO 50
	CALL RMPAUSE(ICHAN,0)
	WRITE (*,45) 'Green',IGREEN
	IGREEN=MIN(NCOL,MAX(IREADVAL1(IGREEN,IEND),0))
	IF (IEND.LT.0) GOTO 50
	CALL RMPAUSE(ICHAN,0)
	WRITE (*,45) 'Blue ',IBLUE
	IBLUE=MIN(NCOL,MAX(IREADVAL1(IBLUE,IEND),0))
	IF (IEND.LT.0) GOTO 50
C
50	CONTINUE
	IRED=IRED*128
	IGREEN=IGREEN*128
	IBLUE=IBLUE*128
	CALL RMWRCOLIND(ICHAN,IRED,IGREEN,IBLUE,INDEX,IERR)
	GOTO 10
	END

C
	SUBROUTINE RAMMAP2T(IARRAY,NA,MA,N,M,IXS,IYS,BX,BY)
C
C	PROGRAM TO MAKE AN IMAGE MAP ON THE RAMTEK DEVICE
C
C	AUTHOR: DG LONG, JPL
C	DATE: 17 JAN 1991
C
C	INPUTS:
C	  IARRAY  : COLOR CODE (RAMTEK COLOR CODE NUMBERS)
C	  NA,MA	  : DIMENSIONS OF IARRAY
C	  N,M	  : PLOT N BY M PORTION OF IARRAY
C	  IXS,IYS : POSITION OF LOWER LEFT CORNER OF MAP (IN RAMTEK PIXELS)
C	  BX,BY   : BOX SIZE (IN RAMTEK PIXELS: 0 < BX < 1024)
C			IF BY < 0 REVERSE ARRAY
C
C	CALLS:
C	  RMPLOT
C
	INTEGER*2 IARRAY(NA,MA)
	COMMON/RMTEK/ICHAN,IRM(128),RRE(2),ROX,ROY,RSF,NIRM,RANG,MM,IPW,
     $		IPSC,ICOL,RVP(4),IRID,RLIM(2),IRXLIM,IRYLIM,IDDEV
	SAVE /RMTEK/
	COMMON/ASTC/IASTFL,IASTPL			! CONTROL-C
	SAVE /ASTC/
	INTEGER MPLOT(4)
C
C	MAKE MAP IN ROW ORDER FOR EFFICIENCIES SAKE
C
	IF (ICHAN.LT.0) RETURN
	DO 10 IX=1,N
		DO 5 IY1=1,M
			IY=IY1
			IF (IBY.LT.0) IY=M-IY1+1
			JNT=IARRAY(IX,IY)
			MPLOT(1)=IXS+NINT(BX*(IX-1))
			MPLOT(2)=IYS+NINT(BY*(IY1-1))
			MPLOT(3)=IXS+NINT(BX*IX)
			MPLOT(4)=IYS+NINT(BY*IY1)
			CALL RAMBOX3(ICHAN,MPLOT(1),MPLOT(2),
     $				MPLOT(3),MPLOT(4),JNT)
			IASTPL=0				! CONTROL-C
			IF (IASTFL.NE.0) CALL ASTINTER(IASTFL)	! CONTROL-C
5		CONTINUE
10	CONTINUE
C
	RETURN
	END 

        subroutine rambox3(i,i1,i2,i3,i4,i5)
        call rambox(i,i1,i2,i3,i4,i5)
        return
        end




